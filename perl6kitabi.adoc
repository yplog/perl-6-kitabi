= Perl 6 Programlama Dili
Yalın Pala <yalinpala@protonmail.com>
:author: Yalın Pala
:email: yalinpala@protonmail.com
:description: Perl 6 Programlama Dili Türkçe Kitap Çalışması
:keywords: perl 6, programlama dili
:Revision: 0.0.1
:icons: font
:source-highlighter: pygments
:source-language: perl6
:pygments-linenums-mode: table
:toc: left
:doctype: book
:lang: tr
:imagesdir: img
:title-logo-image: image:2000px-Camelia.png[pdfwidth=4.25in,align=center]

include::sections/onsoz.adoc[]

<<<

include::sections/giris/giris.adoc[]

<<<

include::sections/giris/perl-6-nedir.adoc[]

<<<

include::sections/giris/perl-versiyonlari.adoc[]

include::sections/giris/perl-5-versiyonuna-asinalar-icin-bir-rehber.adoc[]

<<<

include::sections/giris/kutuphane-destegi.adoc[]

<<<

include::sections/giris/neden-perl-6.adoc[]

<<<

include::sections/ilk-adimlar/perl-6-ile-ilk-adimlar.adoc[]

<<<

include::sections/ilk-adimlar/perl-6-kurulumu.adoc[]

<<<

include::sections/ilk-adimlar/temel-komut-satiri-ozellikleri.adoc[]

<<<

include::sections/ilk-adimlar/etkilesimli-perl-6.adoc[]

<<<

include::sections/ilk-adimlar/metin-editorleri-ve-tumlesik-gelistirme-ortamlari.adoc[]

<<<

include::sections/ilk-adimlar/ilk-programimiz.adoc[]

<<<

include::sections/temeller/perl-6-temelleri.adoc[]

<<<

include::sections/temeller/dokumantasyonu-okumak.adoc[]

<<<

include::sections/temeller/unicode-kullanimi.adoc[]

<<<

include::sections/temeller/islecler.adoc[]

<<<

include::sections/temeller/yorumlar-ve-aciklama-satirlari.adoc[]

<<<

include::sections/temeller/pod.adoc[]

<<<

= Temel Veri Tipleri ve Değişken Kullanımı

Bu bölümde, diğer dillerden aşina olduğumuz temel veri türlerini Perl 6 üzerinde ele alacağız.

Perl 6, statik tipli dillerde olduğu gibi değişkenin tipinin baştan belirlendiği ve program boyunca tipinin değişmediği bir dil değildir. Kademeli tip(_gradual type_) belirtme kullanan bir dildir, yani oluşturduğumuz değişkenlerin tiplerini belirtmeyebileceğimiz anlamına gelir. Farklı türdeki verileri tanımlamak için aynı değişkeni kullanabiliriz. Aynı zamanda oluşturulan değişken için tür de belirtmemize izin verir ve bu değişkenin farklı veri türleri için kısıtlayabilir.

<<<

== Değişken Tanımlamak ve Değer Atamak

Her değişken program içerisinde kullanılmadan önce oluşturulmalıdır. Bir değişken oluştururken *my* anahtar kelimesini kullanırız. *my* geçerli kapsam için değişken tanımlar. Kapsamlara ileride değineceğiz.

```perl6
my $degisken;
```

Şeklinde bir değişken oluştururuz. Kullanımda gördüğümüz gibi önce _my $degişken-adı_ şeklinde bir kullanımı vardır. Bu kullanım bize bir değişken oluşturur ve bu değişken için _(Any)_ tipinde bir dönüş yapar. Yani bu değişken herhangi bir şey olabilir.

```bash
> my $degisken;
(Any)
```

Bir kere tanımlanmış değişkene değer atamak için *=* işleci kullanılır.

```bash
> $degisken = 1;
1
> $degisken
1
```

Bu değişken sabit değişken(Sabit değişkenleri ileride göreceğiz.) olmadığı için değerini istediğimiz zaman değiştirebiliriz.

```bash
> $degisken = 5;
5
```

Bir diğer değişken oluşturma yöntemi ise değişkenin değerini değişkeni oluşturken belirtmektir.

```bash
> my $deg = 2;
2
> $deg;
2
```

Yeri gelmişken noktalı virgül işareti Perl 6'ya ifadenin bittiğini belirtir. 

*$* işareti değişkenin yapısal tipini belirtir ve her zaman değişken adının önünde bulunur. $ ile sembolize edilen veri tipleri skaler veriler olarak geçer. İleride değineceğimiz diziler *@* ile sembolize edilirken hash yapıları *%* ile sembolize edilir. Bu kodun okunaklığını arttırır ve kullanım kolaylığı sağlar.

Bu sembollerin kullanılmaması hataya sebep olur.

```bash
> my sayi = 2;
===SORRY!=== Error while compiling:
Malformed my (did you mean to declare a sigilless \sayi or $sayi?)
------> my sayi⏏ = 2;
```

Değişkenleri adlandırırken dikkat etmemiz gereken kurallar vardır. Bir değişken sayı veya harf ile başlamalı, alt çizgi, tire, veya kesme işareti içerebilir.

```perl6
> my $ad_soyad;
(Any)
> my $ad-soyad;
(Any)
> my $ad'soyad;
(Any)
```

Değişken adlarının hepsi doğru ve birbirinden farklıdır. Ancak -, ' gibi işaretlerden sonra mutlaka bir harf gelmeli ve tekrar etmemelidirler. Örneğin aşağıda geçersiz isimlendirmeleri görüyoruz.

```bash
> my $ad--soyad
> my $ad''soyad
> my $'adsoyad
> my $adsoyad-1
```

Bunların tümü hatalıdır.

Skaler veriler bir tam sayı, kayan noktalı sayı, karakter dizileri gibi tek bir değeri saklayabilen verilerdir.

Biraz daha kullanım örneği yapalım.

```bash
> my $a = 2;
2
> my $b = $a * 5;
10
> say "\$b değişkenin değeri: $b";
$b değişkenin değeri: 10
```

*\* işareti ile o değişkeni işleme sokmadan yazdıracağımızı belirttik.

```bash
> my $ad = 'Yalın';
Yalın
> my $soyad = 'Pala';
Pala
> say "Merhaba, $ad $soyad.";
Merhaba, Yalın Pala.
> say 'Merhaba, $ad $soyad';
Merhaba, $ad $soyad
```

Burada çift tırnak işareti ile tek tırnak işaretinin kullanım farklılığını görüyoruz. Çift tırnak işareti ekrana yazarken değişkenlerimizi işleme sokmuşken, tek tırnak işareti değişkenlerin varlığını umursamamış ve onlara karakter gibi davranmıştır.

<<<

== Sayılar

Bu bölümde tam sayıları(integer), rasyonel(rational) sayıları, kompleks(complex) sayıları göreceğiz. Kısaca aşinalık sağlamak için aşağıdaki gibi bir tablo yapabiliriz.

|=== 
| Değer | Sınıf(Class) | Açıklama  
| 12 | Int | Tam Sayı
| 3.1415926 | Rat | Rasyonel Sayı
| 6.026e34 | Num | Bilimsel Gösterim
| 1+0i| Complex | Kompleks, Karmaşık Sayılar
|=== 

```bash
> say 42;
42
> say 2123123123131231312312312312312123132123123123121231212311231231
2123123123131231312312312312312123132123123123121231212311231231
```

Burada ondalık(decimal) gösterim kullandık ancak Perl 6 bize çok daha fazlasını sunmakta onaltılık(Hexadecimal), sekizlik(octal), ikilik(binary) gösterimleride kullanabiliriz.

```bash
> say 13
13
> say :2<1101>
13
> say :8<15>
13
> say :16<D>
13
> say :16<d>
13
```

Şeklinde sayı sistemlerini kullanabiliriz. Alfabetik karakterler büyük-küçük harf duyarlılığına sahip değildir.

Büyük sayıların okunabilirkiğini arttırmak için *_* alt tire işareti kullanabiliriz.

```bash
> say 1_000_000_000
1000000000
> say 599_999_99_99
5999999999
```

Şimdi bazı tam sayı metotlarına bakalım:

*.chr:* Bir tam sayı değeri karaktere çevirir.

```bash
> say 65.chr
A
> say 66.chr
B
```

*.is-prime:* Bir tam sayının asal olup olmadığını kontrol eder.

```bash
> 3.is-prime
True
> 8.is-prime
False
```

*.rand:* Belirli aralıkta rastgele sayı üretir.

```bash
> 10.rand
7.951998306157705
> 100.rand
23.118963811372407
> 100.rand.truncate
74
> 10.rand.truncate
6
> 10.rand.truncate.WHAT
(Int)
> 10.rand.WHAT
(Num)
```

Burada _.rand_ metodunun sonucunu *.truncate* metodu ile yalnızca tam sayı kısmını almasını söyledik. tip dönüşüm işlemlerine ileride değineceğiz. _.WHAT_ metodu bize hangi sınıfa ait bir veri ile çalıştığımızı döndürdüğünü hatırlayalım.

```bash
> my $a = 1/4
0.25
> $a.WHAT
(Rat)
> $a.numerator
1
> $a.denominator
4
> (1/4 + 1/3).perl
<7/12>
```

Bir rasyonel sayının pay ve paydasını *.numerator* ve *.denominator* metotları ile bulabiliriz.

*.perl* metodu ise rasyonel işlemler yapmamızı sağlar. Pay ve paydayı korur. 

Bir rasyonel sayıyı yuvarlamak istiyorsak *.round* metodunu kullanabiliriz.

```bash
> 2.2.round
2
> 2.6.round
3
```

Bir sayının işaretini *.sign* metodu ile öğrenebiliriz. Bu metot sayı eksi ise *-1* artı ise *1* sonucunu döner.

```bash
> 3.sign
1
> -3.sign
-1
```

<<<

== Karakter Dizileri

Karakter dizileri(String) *Str* sınıfından türetilmiş nesnelerdir. Hemen bir örnek vermek gerekirse:

```bash
> my $karakter-dizisi = "Ben bir karakter dizisiyim!"
Ben bir karakter dizisiyim!
> $karakter-dizisi.WHAT
(Str)
```

Karakter dizilerini ekrana yazdırırken bize yardımcı olan kaçış karakterleri vardır. Örneğin:

```bash
> say "Ankara'da"
Ankara'da
> say 'Ankara'da'
[hata mesajı]
```

Tırnakların kullanımı karakter dizileri için önemlidir. Peki yukarıda hata mesajı aldığımız ifadeyi nasıl yazabilirdik. İşte bu noktada kaçış karakterleri dediğimiz karakterler işimize yarar.

```bash
> say 'Ankara\'da'
Ankara'da
> say 'Ankara \\ Yenimahalle'
Ankara \ Yenimahalle
```

Bu kullanımı önceki bölümlerde değişkenin işleme sokulmadan yazdırılması için de kullandığımızı hatırlayın. Burada ters eğik çizginin(*\*) kaçış karakteri olduğunugörüyoruz. Ekrana ters eğik çizgi yazdırmak için iki ters eğik çizgi kullanıldığına diikat edelim.

Bazı kaçış dizisi karakterlerine bakalım.

|=== 
| Karakter | Açıklama  
| \a | Ses karakteri
| \b | Geri alma tuşu
| \n | Yeni satır
| \t | Tab
| \f | Form
| \c[NAME] | Karakter adıyla
| \q[...] | Tek tırnaklı yazım
| \qq[...] | Çift tırnaklı yazım
| \x[ABCD] | Hex kodu ile karakter yazım
|===

Farklı bir kullanım tekniği ise daha özgür bir kullanım imkanı sunan *q<sınırlayıcı>* kullanımıdır. Bu kullanımda istediğimiz sırılayıcı karakterleri kullanabiliriz. 

```bash
> say q<<Ankara'da biri var>>
Ankara'da biri var
> say q{Ankara \ Yenimahalle}
Ankara \ Yenimahalle
```

İki karakter dizisini birleştirmek için *~* işlecini kullandığımızı görmüştük.

```bash
> my $ad = 'Yalın';
Yalın
> say "Merhaba " ~ $ad ~ "!";
Merhaba Yalın!
> say "Merhaba" ~ " " ~ "Dünya"
Merhaba Dünya
```

Farklı bir karakter dizisi birleştirme yöntemi ise *join* fonksiyonu kullanmaktır. *.chars* metodu ise bize karakter dizimizin boyutunu verir. *.uc*(_uppercase_) metodu ile karakter dizisi içerisindeki tüm karakterleri büyük, *.lc*(_lowercase_) metodu ile küçük harfe çevirdik. *.tc* metodu ile ilk karakteri büyük, *.tclc* metodu ile ilk karakteri büyük, kalan karakterleri küçük hale çevirdik.

```bash
> my $ad-soyad = join ' ', 'Yalın', 'Pala'
Yalın Pala
> 'Yalın'.chars
5
> 'yalın'.uc
YALIN
> 'YalıN'.lc
yalın
> 'Yalın PALA'. tclc
Yalın pala
```

Bir karakter dizisinin içine bakmak istersek *.contains()* metodunu kullanabiliriz. Metot karakter dizimizin içine bakarak belirttiğimiz karakterin veya karakterlerin, karakter dizisi içerisinde varsa _True_ yoksa _False_ sonucunu döner. Metodun büyük-küçük harf duyayarlılığı vardır.

*.start-with()* metodu ile metnin başlangıç karakterlerini, *.ends-with()* ile bitiş karakterlerinin belirttiğimiz karakterler olup olmadığını sorgulayabliriz.

```bash
> 'Örnek cümlemiz Perl 6 karakter dizileri'.contains('perl')
False
> 'Örnek cümlemiz Perl 6 karakter dizileri'.contains('Perl')
True
> 'Örnek cümlemiz Perl 6 karakter dizileri'.contains: 'Perl'
True
> 'Örnek cümlemiz Perl 6 karakter dizileri'.starts-with('Örne')
True
> 'Örnek cümlemiz Perl 6 karakter dizileri'.starts-with: 'leri'
False
> 'Örnek cümlemiz Perl 6 karakter dizileri'.ends-with: 'leri'
True
```

*.fc* metodu ile büyük-küçük harf duyarlılığını kapatabiliriz.

```bash
> 'Örnek cümlemiz Perl 6 karakter dizileri'.starts-with: 'örnek'
False
> 'Örnek cümlemiz Perl 6 karakter dizileri'.fc.starts-with: 'örnek'
True
```

*.index:* ile bir karakterin kaçıncı sırada olduğunu öğrenebiliriz. Burada dikkat etmemiz gereken nokta *.chars* metodundan farklı olarak *.index:* metodu saymaya sıfırdan başlar. Olmayan bir karakter girdiğimizde ise _Nil_ sonucunu döner.

```bash
> 'Yalın'.index: 'ı'
3
> 'Yalın'.index: 'm'
Nil
```

Bir karakter dizisi içerisinden bir aralığın içerisini görmek istersek *.substr:* metodunu kullanabiliriz.

```bash
> 'Yalın Perl 6 Kitabı yazıyor...'.substr: 6, 6
Perl 6
> 'Yalın Perl 6 Kitabı yazıyor...'.substr: 13
Kitabı yazıyor...
```

İlk kullanımda 6. karakterden başla ve 6 karakteri getir dedik. İkinci bir parametre kullanmazsak karakter dizisi bitene kadar anlamına gelir.

Farklı bir metin kullanım yöntemi ise *Q* kullanımıdır. Q daha genelleştirilmiş bir kullanım sunar. Q tek başına kullanıldığında q gibi davranır.

```bash
> say Q<<Ankara'da biri var>>
Ankara'da biri var
> say Q{Ankara \ Yenimahalle}
Ankara \ Yenimahalle
```

Q işleminin davranışını değiştirmek için parametreler kullanırız. Bu parametreler Q harfinden sonra gelir ve : ile başlarlar.

```bash
> Q :q 'Bu metin \' işaretleri ile sınırlıdır. \\'
Bu metin ' işaretleri ile sınırlıdır. \
> Q :q <Bu metin ' ile değil \< ile sınırlıdır.>
Bu metin ' ile değil < ile sınırlıdır.
> Q :single 'Bu metin \' işaretleri ile sınırlıdır. \\'
Bu metin ' işaretleri ile sınırlıdır. \
```

*:q* parametresinin uzun hali *:single* parametresidir, ikiside aynı işi yapar. Bunun gibi *:qq* parametresinin uzun hali *:double* parametresidir.

```bash
> my $ad = 'Yalın'
Yalın
> Q :q 'Merhaba $ad'
Merhaba $ad
> Q :qq 'Merhaba $ad'
Merhaba Yalın
> Q :double 'Merhaba $ad'
Merhaba Yalın
```

*:c* parametresi ise yalnızca süslü parantez içini işleme sokar. *:s* parametresi ise yalnızca değişkenleri işleme sokar. *:b* parametresi ise yalnızca kaçış karakterleri ile ilgilenir. Q parametreleri birlikte kullanılabilir.

```bash
> Q :c 'Merhaba $ad \n {2 ** 4}'
Merhaba $ad 16
> Q :c 'Merhaba \n {$ad}'
Merhaba Yalın
> Q :s 'Merhaba $ad \n {2 ** 4}'
Merhaba Yalın \n {2 ** 4}
> Q :b 'Merhaba $ad \n {2 ** 4}'
Merhaba $ad
 {2 ** 4}
> Q :c :s :b 'Merhaba $ad \n {2 ** 4}'
Merhaba Yalın
 16
```

Bazı Q parametrelerinin bir tablosu:

|=== 
| Kısa Ad | Uzun Ad | Açıklama  
| :x | :exec | Shell komutunu çalıştırır ve sonucu döner.
| :q | :single | Kaçış karakterleriyle işleme girer.
| :qq | :double | :s, :a, :h, :f, :c, :b ile işleme girer.
| :s | :scalar | $ değişkenleri ile işleme girer.
| :a | :array | @ değişkenleri ile işleme girer.
| :h | :hash | % değişkenleri ile işleme girer.
| :f | :function | & çağrıları ile işleme girer. 
| :c | :closure | {...} süslü parantez içi ile işleme girer.
| :b | :backslash | Kaçış karakterleri ile etkileşime girer.
| :to | :heredoc | Here doc ayrıştırma sonucu.
| :v | :val | Mümkünse allomorph a dönüştürür.
|===

Son olarak *Here Doc*'tan bahsedelim. Here doc çok satırlı bir metin yazmanın özel bir yoldur. *:heredoc* veya kısaca *:to* parametresi ile tanımlanır.

```perl6
my $cok-satirli = Q :to<END>;
    Tıkanma'dan bir alıntı:
        Sahip olacağım her şey bir gün kaybedeceğim şeylerden sadece biri.
    Tıkanma'nın yazarı: Chuck Palahniuk
    END

say $cok-satirli; 
```

Kodun çıktısı:

```bash
Tıkanma'dan bir alıntı:
    Sahip olacağım her şey bir gün kaybedeceğim şeylerden sadece biri.
Tıkanma'nın yazarı: Chuck Palahniuk
```

:to parametresinden sonra gelen kapsayıcılar değişebilir. Örneğin // kullanılabilir. Kapsayıcının içerisine yazılan ifade de değişebilir ancak mutlaka son ifade ile aynı olması gerekir.

Here doc değişken kullanımını desteklemez. Eğer değişken kullanmak istiyorsanız farklı parametreler ile birlikte kullanmalısınız.

```perl6
my $yazar = 'Chuck Palahniuk';

my $cok-satirli = Q :qq :to<ALINTI>;
    Tıkanma'dan bir alıntı:
        Sahip olacağım her şey bir gün kaybedeceğim şeylerden sadece biri.
    Tıkanma'nın yazarı: $yazar
    ALINTI

say $cok-satirli; 
```

Kodumuzun çıktısı:

```bash
Tıkanma'dan bir alıntı:
    Sahip olacağım her şey bir gün kaybedeceğim şeylerden sadece biri.
Tıkanma'nın yazarı: Chuck Palahniuk
```

<<<

== Sabitler

Perl 6'da diğer dillerden aşina olduğumuz sabitler, bir değişkenin değerinin bir kere belirlenebildiği değişkenler vardır.

Sabitler *constant* anahtar kelimesi ile oluşturulur.

```bash
> constant $A = 4
4
> $A
4
> $A = 2
Cannot assign to an immutable value
  in block <unit> at <unknown file> line 1
```

Yukarıdaki örnekte de gördüğümüz gibi bir sabitin değerini değiştirmeye çalıştığımız da hata ile karşılaşırız. Yine değişkenlerden farklı olarak sabitlere ilk değer ataması yapılmak zorundadır aksi durumda hata ile karşılaşılır.

Sabitler varsayılan olarak *our* kapsayıcısını alır. Ancak *my* kapsayıcısını da alabilirler. Kapsayıcılara ilerideki bölümlerde değineceğiz.

```bash
> my constant $B = 4
4
> $B
4
> $B = 2
Cannot assign to an immutable value
  in block <unit> at <unknown file> line 1
```

Sabit adlandırırken büyük harfler kullanılması güzel bir alışkanlıktır.

Sabitleri tanımlarken değişken adını işaretsiz($, @, % olmaksızın) belirtebiliriz.

```bash
>constant DENEME = "Deneme"
Deneme
> DENEME
Deneme
> DENEME = "Fark!"
Cannot modify an immutable Str (Deneme)
  in block <unit> at <unknown file> line 1
```

Sabitleri oluşturmanın farklı bir yoluda işaretsiz değişken kullanımı gibi olan *\degisken* şeklinde kullanımdır.

```bash
> my \sabit = 4
4
> sabit
4
> \sabit
\(4)
> sabit = 3
Cannot modify an immutable Int (4)
  in block <unit> at <unknown file> line 1

> \sabit = 3
Cannot modify an immutable Capture (\(4))
  in block <unit> at <unknown file> line 1
```

<<<

== Değişken Tanımlama Yöntemleri

Perl 6 da değişkenlerin tiplerinin belirtilebileceğini söylemiştik. Bu bölümde değişken tanımlamanın farklı yöntemlerini göreceğiz.


=== Değişken Tipi Belirtme

Bir değişkenin tipini *my tip değişkenadı* şablonuna göre belirtiriz.

```bash
> my Int $a
(Int)
> $a = 4
4
> $a = "12"
Type check failed in assignment to $a; expected Int but got Str ("12")
  in block <unit> at <unknown file> line 1
> $a = 4.5
Type check failed in assignment to $a; expected Int but got Rat (4.5)
  in block <unit> at <unknown file> line 1
```

Örneğimizde görüldüğü gibi değişken tipi belirtildikten sonra o değişkenin tipinin dışında bir tipte değer alması hataya sebep olur.

```bash
> my Str $b = "Bir karakter dizisi"
Bir karakter dizisi
> $b = "farklı bir  karakter dizisi"
farklı bir karakter dizisi
> my Bool $c = True
True
```

Ancak aynı tipte olmak üzere değeri değiştirilebilir.

Şuana kadar gördüğümüz ve göreceğimiz, oluşturabileceğimiz bütün tipleri değişken oluştururken kullanabiliriz.

Farklı olarak sabitlerin tiplerini belirtemeyiz.

```bash
> constant Int $a = 4
===SORRY!=== Error while compiling:
Missing initializer on constant declaration
------> constant Int⏏ $a = 4
```


=== Çoklu Değişken Tanımlama

Elbette her satırda bir değişken tanımlamak zorunda değiliz. Bir satırda birden fazla değişken tanımlayabiliriz.

```bash
> my ($e, $f, $g)
((Any) (Any) (Any))
> $e = "e"
e
> $f = "f"
f
> $g = "g"
g
```

Tanımlama esnasında değer belirtebiliriz ve yine tek satırda bu değerleri değiştirebiliriz.

```bash
> my ($a, $b) = 1, 2
(1 2)
> $a
1
> $b
2
> ($e, $f, $g) = 1, 2, 3
(1 2 3)
> $g
3
> $f
2
> $e
1
```

Ayrıca bir önceki bölümde gördüğümüz gibi çoklu tanımlama yaparken de tip belirtebiliriz.

```bash
> my Str ($c, $d) = "Farklı", "kullanım"
(Farklı kullanım)
> $c
Farklı
> $d
kullanım
```

<<<

== Değişkenlerin Kapsamı ve Bloklar

Bloklar bir veya daha fazla ifadeyi süslü parantezler *{ ... }* ile çevirerek tek bir birim altında toplar. 

Bloklar döngüler, koşullar gibi ifadeler de görülebileceği gibi ifadesizde görülebilir. 

Bir blok kendi kapsamını yaratır.

```perl6
my $ad = "Yalın";
say $ad;

{
    # Burası bir blok
    my $ad = "Asu";
    say $ad;
}

say $ad;
```

Bu kodun çıktısı aşağıdaki gibi olur.

```bash
Yalın
Asu
Yalın
```

Bir blok icerisinde tanimlanan ifadeler yalniz o blok icerisinde kalan alanda gecerliligini korur.

<<<

== Tip Dönüşümleri

Genellikle bir değişkenin tipini değiştirmek için *$degisken.Tipadı* gibi bir kullanım vardır.

Bir kullanım çeşidi ise bir string ifadenin başına *+* işleci koymaktır. Bu değişkeni en olası numerik tipe çevirmeye çalışır. Tam tersi numerik bir tipi string'e çevirmek için *~* işleci numerik ifadenin başına konur.

```bash
> my $a = 3
3
> $a.WHAT
(Int)
> $a.Str.WHAT
(Str)
 my $b = 4.5
4.5
> $b.Int
4
> my Str $c = $b.Str
4.5
my Rat $d = +$c
4.5
> $d.WHAT
(Rat)
my Str $e = ~$b
4.5
> $e.WHAT
(Str)
```


<<<

= Listeler

