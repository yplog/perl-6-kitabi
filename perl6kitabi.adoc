= Perl 6 Programlama Dili
Yalın Pala <yalinpala@protonmail.com>
:author: Yalın Pala
:email: yalinpala@protonmail.com
:description: Perl 6 Programlama Dili Türkçe Kitap Çalışması
:keywords: perl 6, programlama dili
:Revision: 0.0.1
:icons: font
:source-highlighter: pygments
:source-language: perl6
:pygments-linenums-mode: table
:toc: left
:doctype: book
:lang: tr
:imagesdir: img
:title-logo-image: image:2000px-Camelia.png[pdfwidth=4.25in,align=center]

= Önsöz

Kitap hiç programlama bilmeyen kullanıcılar için uygun olmayabilir. Ancak başka diller ile çalışmış kişilerin bu kitabı kolayca okuyacaklarını düşünüyorum.

Kitap boyunca, Perl 6 diline özel konulara ağırlık vermeye, çok sayıda örnek kod koymaya, örnek kodların kolay anlaşılır türden olmasına gayret gösterdim. Umarım sizlerde okurken, uygularken keyif alırsınız.

Kitap yayımlandığı sırada henüz Perl 6 ile ilgili çok az Türkçe kaynak vardı. Bu nedenle Perl 6 dili için ilk Türkçe kitap olan bu çalışmada özellikle Türkçe ifadeler kullanmaya özen gösterdim. Eğer ülkemizde Perl 6 ile yapılan çalışmalara birazcıkta olsa katkım olabilirse, ne mutlu bana.

<<<

= Giriş

Bu bölümde dilin genel özelliklerine, nasıl bir süreçten geçtiğine değineceğiz. İlerideki bölümlerde burada üzerinde konuştuklarımızı detaylandıracak ve kod örneklerine geçeceğiz.

Öncelikler Perl 6 dilinin ne olduğundan bahsedeceğiz, Perl 5 ile nasıl bir ilişkisi olduğuna değineceğiz, kütüphane kavramına değineceğiz ve son olarak neden Perl 6’yı kullandığımızdan bahsederek bölümü bitireceğiz.

<<<

== Perl 6 Nedir?

[quote, Larry Wall]
____
Perl 6’nın  gelişimini açıkladığımda, bunun bir topluluk tasarımı olacağını söylemiştim. Perl’ü kendim tasarladım. Bu benim kendi beyin gücümle sınırlı. Bu yüzden Perl 6’nın bir topluluk tasarımı olmasını istedim.
____

Perl 6 yüksek seviyeli, genel amaçlı Perl programlama dili ailesine dahil bir programlama dilidir. Kolayca öğrenilebilecek, yazılıp okunabilecek şekilde tasarlanmıştır. Tecrübeli programcılara ifade özgürlüğü verirken, acemi programcıların da yazabilmesine olanak verir.

Kademeli tipleme(Graduall Typed) kullanır. Dinamik diller gibi çalışır, derleme sırasında tip güvenliğini garanti edemediği programları kabul eder. Ancak, birçok dinamik dilden farklı olarak, tip kısıtlamarını kabul eder ve uygular. Bunu için ek açıklamalar kullanılır. 

Birçok programlama paradigması destekler. Fonksiyonel, nesne yönelimli, emirsel olarak yazılabilir.

Perl 6 şu anda hevesli gönüllülerden oluşan bir ekip tarafından geliştirilmektedir ve Perl topluluğunun yüksek ideallerini bir üst çitaya taşımayı amaçlamaktadır.

<<<

== Perl Versiyonları

[quote, Perl dilinin mottolarından biri, (Easy things should stay easy hard things should get easier and impossible things should get hard.)]
____
Kolay şeyler kolay olmalı, zor şeyler kolaylaştırılmalı ve imkansız şeyler zorlanmalı.
____

Perl 5, otuz yılı aşkın süredir geliştirilen yüksek seviyeli ve zengin özelliklere sahip bir programlama dilidir. Yüzden fazla platformda çalışır ve hem prototipleme hem de büyük ölçekli projeler için uygundur.

Perl bir dil ailesidir, Perl 6 ise bu ailenin bir üyesidir ancak kendi gelişim ekibine sahip ayrı bir dildir. Varlığının devam edem Perl 5 gelişimi üzerimde önemli bir etkisi yoktur.

Yaklaşık olarak 2000 yılında Perl dilinin revize edilmesi söz konusu olmaya başladı. Perl 5 dilinin kalabalık bir dil olarak görülmesi, yazılan kodların anlaşılmazlığı gibi eleştiriler buna ön ayak oldu.  Perl 6 da tasarımcılar kötü düşündükleri her şeyi attılar ve iyi olduğunu düşündükleri özellikleri sakladılar. Perl 6 aşağı yukarı bu şekilde oluşturuldu.

Perl 6 dilinin size öğreteceği kavramlara bakınca emirli(imperative), fonksiyonel veya nesne yönelimli programlama gibi öğreneceğiniz diğer dillere uygulayabileceğiniz kavramları öğrenmiş olacaksınız.

=== Perl 5 Versiyonuna Aşinalar İçin Bir Rehber

Burası daha önce Perl deneyimine sahip kullanıcılar için bir tür kısa karşılaştırma bölümü. Tabi ki tüm özellikleri karşılaştırmayacağız, burada amacımız küçük farklara değinmek. Daha önce Perl dili kullanmadıysanız bu bölümü atlayabilirsiniz.

Bu rehberin çok daha ayrıntılı haline https://docs.perl6.org/language/5to6-nutshell adresinden ulaşabilirsiniz.

==== CPAN

Modüller için https://modules.perl6.org/ adresine bakabilirsiniz.

Eğer aradığınız modül Perl 6 için henüz yoksa *Inline::Perl5* modülü ile Perl 6 kodunuz içinde Perl 5 modüllerini doğrudan kullanabilirsiniz.

CPAN Butterfly planının parçası olarak bazı modüllerin API'leri korunmaya çalışılarak bir takım Perl 5 modüllü Perl 6'ya taşındı. Bunlara https://modules.perl6.org/t/CPAN5 adresinden ulaşabilirsiniz.

Birçok yerleşik Perl 5 fonksiyonu olduğu gibi Perl 6'ya taşındı ancak aradığınız yerleşik fonsiyonu Perl 6 da kullanmak için P5built-ins modülünü kullanabilirsiniz. Hakkında daha fazla bilgi için https://modules.perl6.org/dist/P5built-ins adresine bakabilirsiniz.

==== Bazı Sözdizimi Farklılıkları

Perl 5 ve Perl 6 arasında bazı sözdizimi farklılıkları vardır. Bunlardan bazılarına bakalım.

Perl 6 isimlendirme kurallarında tire (-), alt çizgi (_), kesme işareti (') ve alfanumerik kullanımına izin verir.

Metot çağrıları Perl 5'den farklı olarak ok(->) yerine nokta(.) kullanılır. Nokta gösterimi kullanım ve standart olarak daha kolaydır.

Boşlukların kullanımın da Perl 5 şaşırtıcı derecede esnektir. Perl 6 daha anlamlı bir söz dizilimi için tasarlanmıştır.
Sonuç olarak sözdiziminde Perl 5'te boşluğun isteğe bağlı olduğu ancak Perl 6'da zorunlu veya yasak olduğu yerler vardır.

* Bir argüman listesinin açılış parantezi öncesi boşluğa izin verilmez.
* Anahtar kelimelerden hemen sonra boşluk kullanılmalı.
* Ön ek veya son eklerden önce boşluk kullanılmaz.
* Aradaki ifadelerin sağına ve soluna boşluk konulur. (4 < 5)

Sözdizimi ile ilgili çok daha fazla bilgiye https://docs.perl6.org/language/syntax#Lexical_conventions adresinden ulaşabilirsiniz.

Perl 5'de değişkenlerin başlarına konulan işaretler nasıl erişildiklerine bağlı olarak değişir, Perl 6'da değişmez.

Ternary operatörü de değişmiştir. Karşılaştırma operatörleri olan *?* ve *:* işaretleri *??* ve *!!* olarak değiştirilmiştir.

Karakter dizilerini birleştirmemizi sağlayan ".", "~" ile değiştirilmiştir.

Ve Perl 6 pek çok değişiklik getirdi, kalanları kitabın ilerleyen bölümlerinde birlikte keşfedelim.

<<<

== Kütüphane Desteği

Nispeten genç bir dil olan Perl 6, Perl 5 ve Python gibi dillerin sağladığı olgun modül ekosisteminden yoksundur. Eklenen modüller her geçen gün artmaktadır ancak işinize yarayacak bir modülü bulamıyorsanız, bu boşluğu doldurmak için C, Python, Perl 5 ve Ruby ile yazılmış kütüphaneleri aramanıza izin veren arayüzler bulunmaktadır.

Örneğin belirli bir Python kütüphanesini seviyorsanız Inline::Python modülünü kullanarak programınıza yükleyebilirsiniz. Bunun gibi arayüz kullanımlarına ilerideki bölümlerde detaylı olarak değineceğiz.

Perl 6 da çeşitli dillerde gördüğümüz (Python - pip, Ruby -gem, vb.) zef adında modern modül yöneticisine sahiptir. Kolay kullanımlı ve hızlıdır. 

Modüller hakkında daha fazla bilgiye https://modules.perl6.org/ adresinden ulaşılabilir.
Detayları sonraki bölümlere bırakıp devam edelim.

<<<

== Neden Perl 6?

Bu bölümde Perl 6’yı çekici bir dil yapan özelliklerden bahsetmeye çalışacağız. Öncelikle hızlı prototip oluşturma deneyimini seviyorsanız, büyük, güvenilir ve yeterli güvenlik özellikleri de istiyorsanız Perl 6 sizin için uygun.

Kademeli tiplemeye(gradual typing) izin verir. Yani bir değişkenin tipini belirtmeyeceğiniz gibi kötüye kullanımını önlemek, güvenlik ve okunabilirlik için değişkenlerin tiplerini belirtebilirsiniz.

Düzenli ifadeler(regex) aracılığıyla metin işleme konusunda üne sahiptir ve harika bir metin işleme dilidir. Perl 6, düzenli ifadeleri kodla aynı düzeye getirerek, bunları alt yordamlar(alt yordamları diğer programlama dillerideki fonksiyonlara benzetebiliriz.)  gibi adlandırmanıza ve hatta nesneye yönelik özellikleri kullanmanıza olanak tanır.

İnanılmaz bir Unicode desteğine sahiptir. Dahili eşzamanlılık ve tembel listeler gibi pek çok özelliğe sahiptir. Hata çıktıları oldukça detaylı ve anlaşılırdır. Son olarak Perl 6 size problemi ve çözümünü farklı yollar ve programlama paradigmaları ile ifade etme özgürlüğü verir.

Listeleyebileceğimiz pek çok özellik var, ama daha da önemlisi dili kullanmak eğlenceli olacak şekilde tasarlandı. Kitap boyunca bu kavramlar ve şaşırtıcı pek çok özellikten daha bahsedeceğiz.

Perl 6’yı kullanmayı tercih etmeyeceğiniz zamanlar tabii ki olacaktır. Hiçbir dil her iş için doğru araç değildir.

<<<

= Perl 6 İle İlk Adımlar

Bu bölümde nihayet ilk kodumuzu yazacağız. Öncelikle kurulum ile başlayacağız, daha sonra REPL ile ilgileneceğiz, editörlere göz atacağız ve küçük bir uygulama yaparak Perl 6 programlama dilinin derinliklerine doğru yol alacağız.

<<<

== Perl 6 Kurulumu

Perl kurulumuna geçmeden önce kısaca jargondan bahsedenim.

* **Rakudo:** Perl 6 derleyicisidir.

* **Zef:** Perl 6 modül yöneticisidir.

* **Rakudo Star:** Rakudo, zef, Perl 6 modül koleksiyonu ve dokümantasyonu içeren pakettir.

* **Rakudobrew:** Rakudo kurulum yöneticisidir.

Bu noktada birden fazla kurulum alternatifimiz var. Rakudo Star kurulumu yapabilirsiniz veya rakudobrew aracılığı ile kurulumu gerçekleştirebilirsiniz. Burada kurulum tamamen kullanıcının insiyatifindedir.

Bu kitap yazılırken son versiyon 2019.03 idi. Kurulum aşamasını bu versiyona göre takip edeceğiz.

Rakudo Star kurulumu için http://rakudo.org/files adresinden işletim sisteminize uygun versiyonu indirip yükleyebilirsiniz.

**Docker** ile kurulum için, Docker’ı destekleyen platformlarda, mevcut Docker Rakudo Star konteynırını Docker hub’dan yükleyebilirsiniz.

```bash
$ docker pull rakudo-star
```

Daha sonra etkileşimli kabuk için aşağıdaki kodu çalıştırabilirsiniz:

```bash
$ docker run -it rakudo-star perl6:2019.03
```

Rakudobrew kurlumu için: https://github.com/tadzik/rakudobrew adresine bakabilirsiniz. Oldukça kolay kurulum adımlarına sahip.

Kaynak koddan derlemek için:

```bash
$ wget https://rakudostar.com/files/star/rakudo-star-2019.03.tar.gz
$ tar xfz rakudo-star-2019.03.tar.gz
$ cd rakudo-star-2019.03
$ perl Configure.pl —gen-moar —make-install —prefix ~rakudo
```

Komutlarını kullanabilirsiniz. Kaynak koddan derleme tecrübesiz kullanıcılar için önermediğim bir yöntem.

Kurulumumuzun başarılı olup olmadığına sistemimizde yüklü olan rakudo versiyonunu aşağıdaki komut ile görebiliriz.

```bash
$ perl6 —version
This is Rakudo version 2019.03-32-g33e2d7f4c built on MoarVM version 2019.03-2-gbb2dc6619
implementing Perl 6.d.
```


Benim sistemim de yukarıdaki çıktıyı oluşturmaktadır. Eğer buna benzer bir çıktı görüyorsanız Perl 6 kurulumunuz başarılı olmuş demektir.

<<<

== Temel Komut Satırı Özellikleri

Perl 6 bir önceki bölümde kullandığımıza(perl6 —version) benzer bazı komut satırı özellikleri ile birlikte gelir.  Bu bölümde bu özellikleri inceleyeceğiz. Komutları kullanırken

```bash
$  perl6 <komut>
```

şeklinde kullanmamız gerekiyor.

=== -h veya --help Komutu:

Bu komut bize yardım yazısının bir çıktısını verir ve kullanabileceğimiz çeşitli komutları ve açıklamalarını burada görebiliriz. Aşağıdaki çıktıya benzer bir çıktı oluşturur.

```bash
$  perl6 -h
[…]
-c                   check syntax only (runs BEGIN and CHECK blocks)
  --doc                extract documentation and print it as text
  -e program           one line of program, strict is enabled by default
  -h, --help           display this help text
  -n                   run program once for each line of input
  -p                   same as -n, but also print $_ at the end of lines
[…]
```

=== -c Komutu:

Programın söz dizilimini kontrol eder ve çıkar, kodu çalıştırmaz. Eğer kodun yazılı olduğu adresi belirtmezsek **Syntax OK** dönüşünü yaparak aynı zamanda herhangi bir söz dizimsel hata ile karşılaşmadığında da aynı dönüşü yapar ve sonlanır. Eğer bir hata ile karşılaşırsa hata mesajı dönerek sonlanır. Ayrıca daha sonra göreceğimiz _BEGIN_ ve _CHECK_ bloklarını çalıştırır.

=== -e Komutu:

Bu komut ile bir kodu komut satırı aracılığı ile yazıp kullanabiliriz. Kısa programlar ve küçük testler için uygundur.

Şimdi bir örnek yapalım. Burada endişelenmenize gerek yok ekrana basit bir “Merhaba Dünya!” yazan programı tek **-e** komutu ile kullanmaya çalışalım. Şu aşamada kodun ekrana Merhaba Dünya yazması gerektiğini bilmemiz yeterli. Oldukça kolay bir kod.

```bash
$  perl6 -e ‘say “Merhaba Dünya”’
Merhaba Dünya
```

Evet kodumuz düzgün bir şekilde çalıştı ve istediğimiz sonucu aldık.

=== -n Komutu:

Programa gönderilen bir metnin her satırı için yazılan komutun tekrar çalıştırılmasını sağlar. Yine buradaki kod parçası ve biraz sihir için endişelenmenize gerek yok kullanım örneği oluşturması için yazıyoruz sadece.

```bash
$ perl6 -n -e ‘say $_’ < davet.txt
Dörtnala gelip Uzak Asya'dan
Akdenize bir kısrak başı gibi uzanan
Bu memleket bizim!
Bilekler kan içinde, dişler kenetli
Ayaklar çıplak
Ve ipek bir halıya benzeyen toprak
Bu cehennem, bu cennet bizim!
Kapansın el kapıları bir daha açılmasın
Yok edin insanın insana kulluğunu
Bu davet bizim!
Yaşamak bir ağaç gibi tek ve hür
Ve bir orman gibi kardeşçesine
Bu hasret bizim!
```

Bu kod parçacığını açacak olursak şöyle bir ifade orataya çıkacaktır. Sana bir dosyayı parametre olarak gönderiyorum bunu dosya bitene kadar **-n** kere **-e** kod parçacığını çalıştır.

Kodumuz tam olarak beklediğimiz gibi çalıştı. Nazım Hikmet’in Davet adlı şiirinin olduğu “davet.txt” dosyamızın içeriğini dosya bitene kadar ekrana yazdı.

=== -p Komutu:

**-n** komutuna benzer bir şekilde çalışır ancak **$_** ifadesinin yaptığı işi program sonunda çalıştırır.

```bash
$ perl6 -p -e ‘say “-“‘ < davet.txt
-
Dörtnala gelip Uzak Asya'dan
-
Akdenize bir kısrak başı gibi uzanan
-
Bu memleket bizim!
-
Bilekler kan içinde, dişler kenetli
-
Ayaklar çıplak
-
Ve ipek bir halıya benzeyen toprak
-
Bu cehennem, bu cennet bizim!
-
Kapansın el kapıları bir daha açılmasın
-
Yok edin insanın insana kulluğunu
-
Bu davet bizim!
-
Yaşamak bir ağaç gibi tek ve hür
-
Ve bir orman gibi kardeşçesine
-
Bu hasret bizim!
```

Kod öncelikle dediğimiz gibi program bitene kadar “-“ işaretini ekrana yazdı ve sonra kodumuzda “$_” ifadesi varmış gibi davranarak ekrana davet.txt dosyasının içerisindeki metnin satırını yazdı.

=== -I ve -M Komutları:

Modülleri programa dahil etmek için kullanılır. -M seçeceği ile modülün adı ve gerekirse -I seçeceği ile modülün dizin yolu belirtilmeli.

=== -v veya —version Komutu:

Bir önceki bölümde de kullandığımız gibi Perl 6 versiyonunun çıktısını ekrana yazar.

=== —stagestats Komutu:

Derleyici tarafından harcanan zamanı, programın derlenmesi ve yürütülmesi zamanlarını ekrana yazdırır.

=== —doc Komutu:

Dokümantasyonu programdan alır ve yazdırır. Dokümantasyondan kast ettiğimiz Pod(Plain Old Documentation) dokümantasyonudur. Buna ilerideki bölümlerde değineceğiz.

=== -V Komutu:

Ekrana konfigürasyon özetini yazdırır. Bu ekrana oldukça uzun bir çıktı yazdırır.

Komutların farklı bir kullanım şekli de çoklu komutlarda ilk tire(-) işaretinden sonra bir tire daha koymadan birleşik şekilde komutun yazılmasıdır. Farklı bir kullanımda komuttan sonra gelen kodumuzdan sonra gelen parametrenin bizim komutumuzda _davet.txt_) farklı yazımıdır. Bu da tamamen okunabilirlikle alakalıdır ve "<" işareti kullanılmadan yazılabilir.

Hemen örneklendirelim:

```bash
$ perl6 -p -e 'say "-"' < davet.txt
[...]
$ perl6 -pe 'say "-"' < davet.txt
[...]
$ perl6 -pe 'say "-"' davet.txt
[...]
```

```bash
$ perl6 -n -e 'say $_' < davet.txt
[...]
$ perl6 -ne 'say $_' < davet.txt
[...]
$ perl6 -ne 'say $_' davet.txt
[...]
```

Son olarak davet.txt dosyamızın her satırı için bir satır numarası yazdıralım ve inceleyelim.

```bash
$ perl6 -ne 'say $++ ~ ". satır: " ~ $_' davet.txt
0. satır: Dörtnala gelip Uzak Asya'dan
1. satır: Akdenize bir kısrak başı gibi uzanan
2. satır: Bu memleket bizim!
3. satır: Bilekler kan içinde, dişler kenetli
4. satır: Ayaklar çıplak
5. satır: Ve ipek bir halıya benzeyen toprak
6. satır: Bu cehennem, bu cennet bizim!
7. satır: Kapansın el kapıları bir daha açılmasın
8. satır: Yok edin insanın insana kulluğunu
9. satır: Bu davet bizim!
10. satır: Yaşamak bir ağaç gibi tek ve hür
11. satır: Ve bir orman gibi kardeşçesine
12. satır: Bu hasret bizim!
```

Kodumuzu inceleyecek olursak şimdiye kadar kullanmadığımız "*$++*" ve "*~*" kullanımını gördük. Şu an için bu kodun ne yaptığını bilsek yeterli. 

*$++* kullanımı ile bize gelen dosyadaki her bir satır için bir sayma oluşturduk. Program sonlanana kadar sayım yapacağız. Perl 6 da sayma işlemi çoğu programlama dilinde olduğu gibi 0'dan başlar.

*~* kullanımı ile karakter dizilerini birleştirdik. Kodumuzda $++ ile ". satır: " karakter dizisini ve $_ işaretinin çıktılarını birleştirmek için kullandık.

$++ ve $_ kullanımları değişken olduğu için doğrudan çift tırnak("") işaretleri arasına yazamadık. Bu nedenle "~" kullandık.

*say* fonksiyonu ile tüm bunları ekrana yazdık.

<<<

== Etkileşimli Perl 6

REPL, Python, Ruby gibi dillerden aşina olunan Okuma-Değerlendirme-Yazdırma-Döngü etkileşimli ortamdır. REPL basitçe yazılan kodu değerlendirir, sonucu gösterir ve tekrar etkileşim bekler.

Teknik olarak bu ekrana etkileşimli kabuk (interactive shell)adı verildiğini bilmemizde fayda var. Etkileşimli kabuk, bizim Perl programlama dili ile ilişki kurabileceğimiz, yani onunla etkileşebileceğimiz bir üst katmandır. Etkileşimli kabuk, asıl programımız içinde kullanacağımız kodları deneme imkanı sunar bize. Burası bir nevi test alanı gibidir. Örneğin bir Perl kodunun çalışıp çalışmadığını denemek veya nasıl çalıştığını, ne sonuç verdiğini görmek istediğimizde bu ekran son derece faydalı bir araç olarak karşımıza çıkar. Bu ortam, özellikle Perl'e yeni başlayanların bu programlama diline aşinalık kazanmasını sağlaması açısından da bulunmaz bir araçtır. Biz de bu bölümde etkileşimli kabuk üzerinde bazı çalışmalar yaparak, Perl'e alışma turları atacağız.

Perl 6 hızlı ve etkin bir arayüz sunar. Bu arayüzü dilin inceliklerini öğrenirken deneme-yanılma yapabilmek açısından oldukça etkili, küçük kodların denenmesi için güzel bir ortamdır. Komut satırına **perl6** yazarak REPL ortamını başlatabilirsiniz.

```bash
$ perl6
To exit type 'exit' or ‘^D'
>
```

">" işareti ile Perl 6 etkileşimli kabuğu bizden girdi bekler. Bir önceki bölümde yazdığımız ekrana “Merhaba Dünya” yazan kodu burada deneyelim.

```bash
> say “Merhaba Dünya”
Merhaba Dünya
```

Beklediğimiz sonucu aldık ve ortam bizden “>” işareti ile yeni bir etkileşim bekliyor. REPL aynı zamanda bir hesap makinesidir. Bir kaç deneme yapalım.

```bash
> 2 + 2
4
> 2 * 3 
6
> 2 ** 12
4096
> 5 / 2
2.5
> 5 % 2
1
> “Merhaba Dünya”
Merhaba Dünya
```

Gibi örnekler yapabiliriz. Alışma aşaması için bu kadar REPL bilgisi bize yeterli ilerideki bölümlerde sık sık kullanacağız.

<<<

== Metin Editörleri ve Tümleşik Geliştirme Ortamları

Çoğu zaman, Perl 6 programlarımız dosyalara yazıp depolayacağımız için, Perl 6 söz dizilimini tanıyan iyi bir editöre sahip olmalıyız. Bu noktada pek çok alternatifimiz bulunmakta.

* **Atom:** Atom editörüne https://atom.io/ adresinden ulaşabilirsiniz. Perl 6 söz dizilimi için https://atom.io/packages/language-perl6 eklentisini yükleyebilirsiniz.

* **Visual Studio Code:** VSCode editörüne https://code.visualstudio.com/ adresinden ulaşabilirsiniz. Perl 6 söz dizilimi için https://marketplace.visualstudio.com/items?itemName=scriplit.perl6-lsp eklentisini kurabilirsiniz.

* **Padre:** http://padre.perlide.org/
* **Comma IDE:** https://commaide.com/

Sublime Text, JetBrains ortamları, Emacs veya Vim gibi metin editörleri kullanıyorsanız Perl 6 eklentileri mevcut. Bu editörlerden herhangi birini kullanabilirsiniz. Basit bir internet aramasıyla daha fazla sonuca ulaşabilirsiniz.

<<<

== İlk Programımız

[quote, Audrey Tang]
Perl 6 eğlence için optimize edilmiştir.

Favori geliştirme ortamımızı kurduğumuzu ve gerekli ayarları yaptığımızı varsayarak yeni bir Perl 6 dosyası oluşturalım. Dokümantasyon dosya uzantısı olarak “**.p6**” veya “**.pl6**” önermesine rağmen Perl 6 uzantıyı önemsemez. Ancak Dokümantasyona sadık kalmak iyi bir alışkanlıktır.

Dosyamızı “**merhaba-dunya.p6**” olarak kayıt edelim.
Dosyamızın içerisine ekrana “Merhaba Dünya” yazan kodumuzu yazalım ve kayıt edelim.

```perl6
say “Merhaba Dünya”
```

Terminal arkalığı ile kodumuzu kayıt ettiğimiz yere gidelim ve dosyamızı çalıştıralım.

```bash
$ perl6 merhaba-dunya.p6
Merhaba Dünya
```

İlk programımız başarı ile çalıştı ve ekrana Merhaba Dünya yazdı.

Programımızı çalıştırmadan önce perl6 komut satırı özelliklerinde gördüğümüz -c parametresi ile bir kontrol yapalım. Hatırlarsanız bu komut programımızın söz dizilimini kontrol ediyordu.

```bash
$ perl6 -c merhaba-dunya.p6
Syntax OK
```

Cevabını bize döndürdü ve sonlandı. Bu demek oluyorki herhangi bir söz dizimsel hata yapmadık. Programımızı biraz değiştirip tekrar deneyelim.

```perl6
say “Merhaba Dünya'
```

Kayıt edip tekrar -c komutu ile çalıştıralım.

```bash
$ perl6 -c merhaba-dunya.p6
Unable to parse expression in double quotes; couldn't find final '"' (corresponding starter was at line 1)
at […]Perl 6 Kitabı/perl-6-kitabı/merhaba-dunya.p6:1
------> say "Merhaba Dünya'⏏<EOL>
    expecting any of:
        argument list
        double quotes
        term
```

Bize bir hata döndü ki bu hatayı tahmin ediyorduk. 
Oldukça açıklayıcı bir hata aldık: İfade çift tırnak içinde değil sonuncu çift tırnağı bulamadım, karşılık gelen başlangıç birinci satırdaydı.

Programlarınızı çalıştırmadan önce -c parametresi uygulamak programın çalışmadan önce söz diziliminde bir hatanız olup olmadığını size bildirecektir.

Sonra yapacağımız örnekler için merhaba-dunya.p6 dosyamızın içerisindeki kodu eski(çalışan) haline getirelim.

Önceki bölümlerde örneklendirmediğimiz bir komutta **—-stagestats** komutuydu. Bu komut hatırlayacağınız gibi derleyici tarafından harcanan zamanı, programın derlenmesi ve yürütülmesi zamanlarını ekrana yazdırıyordu.

```bash
$ perl6 --stagestats merhaba-dunya.p6
Stage start      :   0.000
Stage parse      :   0.241
Stage syntaxcheck:   0.000
Stage ast        :   0.000
Stage optimize   :   0.004
Stage mast       :   0.006
Stage mbc        :   0.001
Stage moar       :   0.000
Merhaba Dünya
```

--stagestats komutu bize adım adım derleyicinin neler yaptığını göstermiş oldu ve son olarak programı çalıştırarak sonlandı.

Perl 6'nın dosya uzantılarını umursamadığını belirtmiştik, şimdi bunun için bir deneme yapaılım. Bu sefer **merhaba-dunya.txt** adında bir dosya oluşturalım ve içerisine ekrana "Merhaba DÜnya" yazan kodumuzu içerisine yazalım ve kayıt edip çalıştırmaya çalışalım.

```bash
$ perl6 merhaba-dunya.txt
Merhaba Dünya
```

Gördüğünüz gibi herhangi bir problem ile karşılaşmadık.

<<<

= Perl 6 Temelleri

Bu bölümde dokümantasyonu okumayı, operatörleri, yorumları, POD dokümantasyonunu, blokları, boşlukları, unicode kullanımını ve basit olarak girdi çıktı işlemlerine değineceğiz.

<<<

== Dokümantasyonu Okumak

Perl 6 dokumantasyonuna komut satirina **p6doc** yazarak ulasabiliriz. p6doc sisteminizde kurulu olarka gelmez. Eger bir hata ile karsilasirsaniz muhtemelen p6doc sisteminizde kurulu degildir. Zef modul yoneticisi ile kurabiliriz.

```bash
$ zef install p6doc
```

Eğer bir sorun ile karşılaşırsanız _--force_ parametresiyle tekrar deneyiniz.

```bash
$ zef install p6doc --force
```

Herhangi bir hata almadıysanız kurulum başarılı demektir. Komut satırına p6doc yazarak kontrol edelim.

```bash
$ p6doc
[...]

What documentation do you want to read?
Examples: p6doc Str
          p6doc Str.split
          p6doc faq
          p6doc path/to/file

[...]
```

Dokumantasyonu kullanmak son derece kolaydir. Şimdi birkaç örnek yapalım:

```bash
$ p6doc Int.is-prime
[...]
Defined as:

    multi sub    is-prime (Int:D $number --> Bool:D)
    multi method is-prime (Int:D: --> Bool:D)

Returns True if this Int is known to be a prime, or is likely to be a prime
based on a probabilistic Miller-Rabin test.

Returns False if this Int is known not to be a prime.

    say 2.is-prime;         # OUTPUT: «True»
    say is-prime(9);        # OUTPUT: «False»

```

Gördüğünüz gibi p6doc bize oldukça detaylı bir sonuç döndü. Kısaca _.is-prime_ fonksiyonun ne yaptığını açıkladı ve kullanım örnekleri verdi.

Dokümantasyondan çıkmak için "**q**" tuşunu kullanabilirsiniz.

Şimdi bu örnekleri deneyelim.

```bash
$ perl6 -e 'say 21.is-prime'
False
$ perl6 -e 'say is-prime(101)'
True
```

**p6doc** dışında https://docs.perl6.org adresinden de dokümantasyona ulaşabilirsiniz.

<<<

== Unicode Kullanımı

Unicode (Evrensel Kod) Unicode Consortium organizasyonu tarafından geliştirilen ve her karaktere bir sayı değeri karşılığı atayan bir endüstri standardıdır. Sistemin amacı farklı karakter kodlama sistemlerinin birbiriyle tutarlı çalışmasını ve dünyadaki tüm yazım sistemlerinden metinlerin bilgisayar ortamında tek bir standart altında temsil edilebilmesini sağlamaktır. 

Perl 6 yüksek seviyede Unicode desteğine sahiptir. 

Örneğin:

```bash
$ perl6 -e 'say "😃"'
😃
$ perl6 -e 'say "𝛂 + 𝛃"'
𝛂 + 𝛃
$ perl6 -e 'say e'
2.718281828459045
$ perl6 -e 'say "Хороший язык."'
Хороший язык.
$ perl6 -e 'say "好语言。"'
好语言
$ perl6 -e 'say ½ + ½'
1
$ perl6 -e 'say π'
3.141592653589793
$ perl6 -e 'say "\c[PILE OF POO]"'
💩
$ perl6 -e 'say "\c[BELL]"'
🔔
$ perl6 -e 'say "dizzy symbol".uniparse;'
💫
$ perl6 -e 'say uniparse("speech balloon"), " Merhaba"'
💬 Merhaba
$ perl6 -e 'say "\x1F4AF"'
💯
```

Şimdi tek bir örnek üzerinden kullanımlara bakalım.

```bash
$ perl6 -e 'say "Bu kopyala yapıştır: 🎉"'
Bu kopyala yapıştır: 🎉
$ perl6 -e 'say "🎉".uniname'
PARTY POPPER
$ perl6 -e 'say "Bu codepoint ismi: \c[PARTY POPPER]"'
Bu codepoint ismi: 🎉
$ perl6 -e 'say "PARTY POPPER".uniparse'
🎉
$ perl6 -e 'say "Bu decimal: \c[127881]"'
Bu deciamal: 🎉
$ perl6 -e 'say "Bu hexadecimal: \x1F389"'
Bu hexadecimal: 🎉
```

Unicode kullanımı Perl 6 da oldukça kolaydır.

<<<

== İşleçler

Bu bölümde, aslında pek de yabancısı olmadığımız ve hatta önceki derslerimizde üstünkörü de olsa değindiğimiz bir konuyu çok daha ayrıntılı bir şekilde ele alacağız. Burada anlatacağımız konu size yer yer sıkıcı gelebilir. Ancak bu konuyu hakkıyla öğrenmenizin, programcılık maceranız açısından hayati önemde olduğunu rahatlıkla söyleyebilirim.

İşleçler sağında ve solunda bulunan değerler arasında ilişki kuran işaretlerdir.

İşleçler değerler üzerinde eylemler gerçekleştirerek sonuç döndürürler. Bu değerlere veya işlecin argümanlarına işlenen denir.

Perl 6 çok sayıda işlecin bulunduğu bir dildir.

İşleçler inflix(bağlama), prefix(önek), postfix(sonek), circumfix(koşulsal) ve postcircumfix(sonrasında koşulsal) durumlarında bulunabilir ve bunlara göre kategorize edilir.
Bunların sözdizimlerine bakalım.

|=== 
| *Bağlama İşleçleri* | işlenen1 + işlenen2  
| *Önek İşleçleri* | +işlenen
| *Sonek İşleçleri* | işlenen+
| *Koşulsal İşleçler* | (işlenen)
| *Sonrasında Koşulsal İşleçler* | işlenen1[işlenen2]
|=== 

Şeklinde kullanılırlar.

Bu bölüm bir tür referans bölümü gibi düşünülebilir. İşleçler kullanıldıkça aklınızda kalacaktır. Bölüm boyunca bazı işleçleri açıklayabilmek ve örneklendirebilmek için henüz kullanmadığımız kod parçaları kullanacağız, bunlar için endişelenmenize gerek yok ileride ki bölümlerde hepsini netliğe kavuşturacağız.


=== Atama Operatörü(=)

Atama işleci "*=*" işaretidir. Bağlama işleci olarak kullanılır. 

```perl6
my $yedi = 7
```

Kudu *$yedi* değişkenine 7 değerini atar.

=== Aritmatik İşleçler

*Toplama(+), Çıkarma(-), Çarpma(*), Bölme(/) İşleçleri:*
```bash
> 1 + 2
3
> 2 - 1
1
> 2 * 2
4
> 4 / 2
2
> 3 / 2
1.5
```

*Kuvvet İşleci (**):*

```bash
> 4 ** 2
16
```

*Tam Sayı Bölme İşleci (div):*

```bash
> 3 div 2
1
> 7 div 3
2
```

*Mod (%):*

```bash
> 7 % 4
3
> 2 % 2
0
> 3 % 2
1
```

*Bölünebilme (%%):* İşlenenler tam bölünebiliyorsa _True_ bölünemiyorsa _False_ sonucunu döner.

```bash
> 7 %% 4
False
> 6 %% 3
True
```

*Sayısal Eşitlik (==) ve Tersi (!=):* İşlenenler birbirine eşitse _True_ değilse _False_ sonucunu döner. Tersi ise tam tersini yapar ve işlenenler birbirine eşit değilse _True_ eşitse _False_ sonucunu döner.

```bash
> 7 == 7
True
> 6 == 3
False
> 7 != 7
False
> 6 != 3
True
```

*Küçük(<), Büyük(>), Küçük Eşit(<=), Büyük Eşit(>=):* 

```bash
> 1 < 2
True
> 1 > 2
False
> 1 <= 2
True
> 2 <= 2
True
> 1 >= 2
False
> 2 >= 2
True
```

*Sayısal Üç Yönlü Karşılaştırma (<=>):*

```bash
> 1 <=> 1.0
Same
> 1 <=> 1
Same
> 1 <=> 2
Less
> 3 <=> 2
More
```

*En Büyük Ortak Bölen ve en Küçük Ortak Kat İşleçleri (gcd, lcm)*

```bash
> 6 gcd 9
3
> 4 lcm 3
12
```

*Önek ve Sonek Arttırma İşleçleri (++işlenen, işlenen++):* *Sonek* olarak kullanıldığında değişkenin değerini döner ve 1 arttırır veya azaltır. *Önek* olarak kullanıldığında değeri 1 arttırır veya 1 azaltır ve değişkenin değerini döner.

```bash
> my $a = 0
0
> $a++
0
> $a
1
> $a--
1
> $a
0
> ++$a
1
> --$a
0
```

=== Karakter Dizisi İşleçleri

*Karakter Dizisi Eşitliği (eq) ve Tersi:* İşlenen Karakter dizileri birbirine eşit ise _True_ değil ise _False_ sonucunu döner. Tersi ise tam tersini yapar ve diziler birbirine eşit değilse _True_ eşitse _False_ sonucunu döner. (Bir hatırlatıcı, eq: equal, ne: not equal)

```bash
> "a" eq "a"
True
> "a" eq "b"
False
> "a" ne "b"
True
> "a" ne "a"
False
```

*Karakter Dizisi Önceliği (lt, gt, le, ge):* Karakterleri sözlüksel sıraya göre karşılaştırır.

```bash
> "a" lt "b"
True
> "a" gt "b"
False
> "a" le "b"
True
> "a" ge "a"
False
```

*Karakter Dizisi Üç Yönlü Karşılaştırma (leg):*

```bash
> "a" leg "a"
Same
> "a" leg "b"
Less
> "c" leg "b"
More
```

*Akıllı Üç Yönlü Karşılaştırma (cmp):* Hem sayısal hem de karakter dizilerini karşılaştırabilir.

```bash
> "a" cmp "b"
Less
> 1 cmp 1
Same
> "c" cmp "b"
More
```

*Karakter Dizisi Olarak Birleştirme (~):*

```bash
> "Merhaba" ~ " Dünya"
Merhaba Dünya
> 1 ~ 2
12
```

*Karakter Dizisi Olarak Çoğaltma (x):*

```bash
> "Merhaba " x 4
Merhaba Merhaba Merhaba Merhaba
> 25 x 4
25252525
```

*Akıllı Eşleme (~~):*

```bash
> "Merhaba" ~~ "Merhaba"
True
> 25 ~~ 25
True
> 25 ~~ "25"
True
> "Merhaba Dünya" ~~ /Merhaba/
｢Merhaba｣
> "Merhaba Dünya" ~~ /Perl/
Nil
> "Merhaba" ~~ Str
True
> 2 ~~ Int
True
```

*Önek Olarak ? İşleci:* İşleneni mantıksal bir veri tipi şeklinde döndürür.

```bash
> ?"Merhaba"
True
> ?""
False
> ?1
True
> ?100
True
> ?0
False
> my $b
(Any)
> ?$b
False
> $b = 3
3
> ?$b
True
```

*Önek Olarak ! İşleci:* İşleneni _False_ ise _True_, _True_ ise _False_ şeklinde döndürür.

```bash
> !"Merhaba"
False
> !""
True
> !1
False
> ?0
True
> my $c
(Any)
> !$c
True
> $c = 2
2
> !$c
False
```

*Bağlayıcı Olarak Aralık İşleçleri (.., ..^, ^.., ^.. ^, ^, ...):*

* *..:* İki işlenen arasında aralık oluşturur.
* *..^:* Son işlenen değeri dahil etmeden bir aralık oluşturur.
* *^..:* İlk işlenen değeri dahil etmeden bir aralık oluşturur.
* *^.. ^:* İşlenen değerleri dahil etmeden bir aralık oluşturur.
* *...:* İşlenen değerler arası bir tembel *liste* oluşturur. Bunun ne olduğuna ilerideki bölümlerde değneceğiz.

```bash
> 1..5
1..5
> 1..^5
1..^5
> 1^..5
1^..5
> 1^..^5 
1^..^5
> 1...1000
(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 ...)
```

*Önek Olarak ^ İşleci:* Sıfırdan başlayarak kendisinden sonra gelen sayıya kadar aralık oluşturur.

```bash
> ^5
^5
```

*Aralıkları Listeye Çeviren | Önek İşleci:*

```bash
> |(1..5)
(1 2 3 4 5)
> |(1..^5)
(1 2 3 4)
> |(1^..5)
(2 3 4 5)
> |(1^..^5) 
(2 3 4)
> |(^5)
(0 1 2 3 4)
```

*İşlenenlerin Yerini Değiştiren R İşleci:*

```bash
> 2 R/ 3
1.5
> 2 R- 1
-1
```

*İndirgeme(Reduction) İşleci:* Lisp dil ailesine aşina kişilere yabancı gelmeyecek bir kullanım sunar.
Örneğin Racket dilinde bir Toplama işlemi yapalım:

```racket
> (+ 1 2 3 4 5)
15
```

Şimdi de Perl 6 ile yapalım:

```bash
> 1 + 2 + 3 + 4 + 5
15
> [+] 1,2,3,4,5
15
> [+] 1..5
15
> 1 * 2 * 3 * 4 * 5
120
> [*] 1,2,3,4,5
120
> [*] 1..5
120
```

*Bağlı(Bound) Kontrol İşleci (=:=):* Her iki işlenende aynı değişkene atanmışsa, yani iki işlenen de aynı referans değere işaret ediyorsa işleç _True_ değerini döndürür. İki işlenenin aynı değişkene bağlı olmasını sağlamak istiyorsak atama işleci(=) değil, bağlama(:=) işlecini kullanırız.

Aynı referans değerden kastetiğimiz ili işleneninde aynı bellek alanını işaret etmesidir.

Biraz kafa karıştırıcı olabilir hemen örneklendirelim.

```bash
> my $a = 1
1
> my $b = $a
1
> $a =:= $b
False
> $b = 2
2
> $a
1
> my $c = "merhaba"
merhaba
> my $d := $c
merhaba
> $c =:= $d
True
> $c = "hello"
hello
> $d
hello
```

Burada $c değişkenin değerini değiştirdiğimiz de bağlı olan $d değişkenin işaret ettiği bellek alanındaki değer değiştiği için iki değişkenimiz de değişmiş oldu.

*Değer Kimliği Kontrol İşleci (===):* Eşitlik kontrolünün sınıfsal farklılıkları da gözeten çeşididir.

```bash
> 12 == 12
True
> 12 == "12"
True
> 12 == 12.0
True
> 13 === 13
True
> 13 === "13"
False
> 13 === 13.0
False
```

Sınıf kavramına kitabın ilerleyen bölümlerinde değineceğiz ancak konun anlaşılması açısından basitçe herhangi bir değere ne(.WHAT) olduğunu sorarak hangi sınıfa mensup olduğunu anlayabiliriz.

```bash
> 14.WHAT
(Int)
> "14".WHAT
(Str)
> 14.0.WHAT
(Rat)
```

*Eşdeğerlik İşleci (eqv):* İki işlenenin eşdeğer olup olmadığını kontrol eder. Değer kimliği kontrol işleci(===) gibi çalışır.

```bash
> 4 eqv 4
True
> 4 eqv 4.0
False
> 4 eqv "4"
False
```

*Yaklaşık Eşitlik İşleci (=~=):* İşlenenler arasındaki fark tölerans değerinden düşükse karşılaştırmanın sonucu _True_ olur. Varsayılan tölarans değeri 1E-15 olan 0.000 000 000 000 001'dir.

```bash
> 1 =~= 1.0000001
False
> 1 =~= 1.000000000000001
True
```

*Minimum ve Maksimum işleçleri (min, max):* Belirtilen işlenenler arasından minimum ve maksimum değerleri döndürür.

```bash
> min(1..10)
1
> max(1..10)
10
> 1 min 2
1
> 4 max 5
5
```

*Önek Olarak ~ İşleci:* İşleneni karakter dizisi şeklinde döndürür.

```bash
> my $a = 3
3
> my $b = ~3
3
> $b.WHAT
(Str)
```

*Önek olarak + İşleci:* İşleneni pozitif sayısal değer şeklinde döndürür.

```bash
> my $a = "3"
3
> my $b = +"3"
3
> $b.WHAT
(Int)
```

*Önek olarak - İşleci:* İşleneni negatif sayısal değer şeklinde döndürür.

```bash
> my $a = "3"
3
> my $b = -"3"
-3
> $b.WHAT
(Int)
```

=== Mantıksal İşleçler

Bu işleçler mantıksal ve(and), veya(or) ve dışlayıcı veya(xor) işlemlerini gerçekleştiren işleçlerdir.

Mantıksal işlenenler _True_ veya _False_ döndürür. Tek istisnası xor işlecinde kullanılan True ^^ True ifadesi _Nil_ döndürür.

Farklı programlama dillerindeki kullanıma benzer şekilde kullanılır.

* Ve(and) işleci için *&&* kullanılır.
* Veya(or) işleci için *||* kullanılır.
* Dışlayıcı Veya(xor) işleci için *^^* kullanılır.

|=== 
| İşlenen 1 | İşleç | İşlenen 2 | Sonuç
| False | && | False | False
| True | && | True | True
| True | && | False | False
| False | && | True | False
| False | *||* | False | False
| True | *||* | True | True
| True | *||* | False | True
| False | *||* | True | True
| False | ^^ | False | False
| True | ^^ | True | Nil
| True | ^^ | False | True
| False | ^^ | True | False
|===


*Tanımlı Veya İşleci (//):* Eğer bir değişkenin değeri varsa onu yoksa belirttiğimiz değeri döndürür.

```bash
> my $ad
(Any)
> $ad // 'Yalın'
Yalın
> $ad = 'Asu'
Asu
> $ad
Asu
> $ad // 'Yalın'
Asu
```

Perl 6 evreninde birçok işleç daha bulunmakta, ancak geri kalanına kitabın ilerleyen bölümlerinde değineceğiz.

<<<

== Yorumlar, Açıklama Satırları

Yorumlar diğer dillerde olduğu gibi derleyici tarafından yok sayılan, yazarların açıklamalarıdır.

Yazdığımız yorumlar Perl 6'ya hiç bir şey ifade etmez. Perl bu yorumları tamamen görmezden gelecektir. Bu yorumlar bilgisayardan ziyade kodları okuyan kişi için bir anlam taşır.

Yorumlar programı geliştiren kişinin kodlar arasına eklediği notlardır. Bu koda dışarıdan bakan, hatta bizzat programı yazanın dahi kodların ne ifade ettiğini anlamasına yardımcı olur ve programın geliştirilmesini, bakımını, anlaşılır olmasını sağlar.

Sizin yazdığınız kodları nasıl başkaları okurken zorlanıyorsa, kendi yazdığınız kodları okurken siz bile zorlanabilirsiniz. Özellikle uzun süredir ilgilenmediğiniz eski programlarınızı gözden geçirirken böyle bir sorunla karşılaşabilirsiniz. Programın içindeki bir kod parçası, programın ilk yazılışının üzerinden zaman geçtikten sonra size artık hiçbir şey ifade etmiyor olabilir. Kodlara bakıp, "Acaba burada ne yapmaya çalışmışım?"" diye düşündüğünüz zamanlar da olacaktır. İşte bu tür sıkıntıları ortadan kaldırmak veya en aza indirmek için kodlarımızın arasına açıklayıcı notlar ekleyeceğiz.

Perl 6 dili bize üç tür açıklama satırı ekleme yöntemi sunmakta.

* Tek Satırlık Yorumlar
* Çok Satırlı Yorumlar
* Gömülü Yorumlar

Bu bölüm boyunca bunları inceleyeceğiz.

<<<

=== Tek Satırlık Yorumlar

Tek satırlık yorumları derleyicinin kodumuzdan ayırabilmesi için "*#*" işareti ile belirtiriz.

*#* işaretinden sonraki her şey satır sonuna kadar Perl tarafından atlanır. Unutmayın yorumlar Perl için değil bizim için gereklidir.

Örnek kullanımı aşağıdaki şekildedir.

```perl6
# Ekrana Merhaba yazan program.
say "Merhaba";
```

Kodu çalıştırdığımızda ise aşağıda gördüğümüz gibi yorum satırımız programa etki etmemiştir.

```bash
$ perl6 tek-satirlik-yorumlar.p6
Merhaba
```

Yorum satırı için herhangi bir sınırınız yoktur istediğiniz kadar yorum yazabilirsiniz.

```perl6
# Bu bir Perl 6 programıdır.
# Ekrana Merhaba yazar.

say "Merhaba";

# Program bitti.
```

Bu aşamada yorumların ne kadar kullanılacağı tamamen yazarın insiyatifindedir.

=== Çok Satırlı Yorumlar

Her ne kadar tek satırlık yorumlar büyük miktarda dokümantasyon sağlamak için kullanılsada her satırda _#_ işaretini kullanmak ve yorumların tek satırdan ibaret olması kısıtlayıcıdır.

Bu noktada Perl 6 bize çok satırlı yorumları işaret eder.

Çok satırlı yorumlar "*#`*" işaretleri ile başlar ve yorumumuzu "()", "[]" veya "{}" parantezler arasına yazarız.

```perl6
#`{
    Bu bir çok satırlı yorumdur.
    Bu kod Yalın Pala tarafından yazılmıştır.
    Ekrana Merhaba yazan bir program yazacağız. 
}

say "Merhaba";

#`( Program burada bitiyor.
    Ancak farklı kullanımlar için örneklendiriyoruz. )

#`[ 
    Bu da farklı bir kullanım şekli.
    Yorumumuz mutlaka parantezler ile sarılmalı.
    Aksi durumda hata alırız.
]
```

Çok satırlı yorumların bir kullanım çeşidide blok olarak kullanımdır. Ancak bu ileride göreceğimiz POD dokümanı oluşturmak amacı ile kullanılmaktadır ve yorum olarak kullanılması önerilmemektedir.

```perl6
=begin yorum
[...]
Burada 
bir 
yorum 
yapıyorum
[...]
=end yorum
```


=== Gömülü Yorumlar

Gömülü yorumlar çok satırlı yorumlar gibi kullanılır ancak kodun içerisine doğrudan göümülüdür.

```perl6
say #`(say kendisinden sonra gelen ifadeyi ekrana yazar) "Merhaba Dünya";

my $a = 1;
my $b = 2;

say $a + #`(+ ile iki değişkeni toplayalım.) $b;
```

Gibi kullanılabilir. Kodu çalıştırdığımızda yorumların göz ardı edildiğini göreceğiz.

```bash
$ perl6 gomulu-yorumlar.p6
Merhaba Dünya
3
```

Gömülü yorumların bir dezavantajı ise kod okunabilirliğini azaltmasıdır. Bu durumun önüne geçmek için gömülü yorumu olabildiğince kısa tutmalıyız.

<<<

== POD

Perl 6 dokümantasyonu yazmak için kullanılan bir işaretleme dilidir. Kodu ifade etmekte daha fazla işlevsellik sağlayan yorumların genişletilmiş bir sürümü olarak kabul edilebilir.

Yorumlar gibi Pod içeriği de kodlarımızı yazdığımız dosyanın içinde barındırılır.

<<<

=== =begin ve =end Blokları

Pod blokları *=begin _tanımlayıcı_* ile başlar ve *=begin _tanımlayıcı_* ile biter. Burada tanımlayıcı Pod içirisinde belirtilen verileri anlatan yazarın verdiği bir tanımdır. Ayrıca bloklar içerisinde kullanılabilecek bazı tanımlayıcılar da vardır.

Bir kodun içerisinde yazılan Pod verisini okumak için programı çalıştırırken *--doc* komutuyla çalıştırırız.

Basit bir Pod dokümanı şuna benzer.

```perl6
=begin pod
Bu bir Pod dokümanıdır.
=end pod

say "Merhaba";
```

Ve --doc komutu ile çalıştıralım.

```bash
$ perl6 --doc basic_pod.p6
Bu bir Pod dokümanıdır.
```

Şimdi de Pod tanımlayıcılarına göz atalım.

=== Paragraf Bloklar

Paragraf blokları *=for _tanımlayıcı_* ile başlar ve kendisinden sonra gelen ilk boş satır veya ilk Pod tanımlayıcısı ile sonlanır.

=for yapısından sonra tanımlayıcı adı gelir. Tanımlayıcı ad gelmezse =for yapısı paragraf şeklinde yazar.

=for yapısının bir avantajı bitişini belirtmememizdir.

```perl6
=for head1
Bu bir başlıktır.

=for param
Burada normal bir paragraftır,
kendisinden sonra gelen ilk boş satırda sonlanacaktır.
```

=== Tek Satırlık Bloklar

*=_tanımlayıcı_* ile başlar ve kendisinden sonra gelen ilk boş satır veya ilk Pod tanımlayıcısı ile sonlanır.

```perl6
=head1 Büyük başlık

=head2 Alt Başlık
```

=== Blok Tipleri

Pod çeşitli standart blok tipleri(_tanımlayıcılar_) sunar.

==== Başlıklar

Başlıklar *headN* şeklinde tanımlanır. N burada sıfırdan büyük sayılardır.

Bunu biraz yukarıda örneklendirmiştik.

==== Paragraflar

*=para* ile kullanılır ancak birkaç farklı kullanım şekli vardır.

```perl6
=head1 Büyük başlık

Invidunt gubergren et sea ea takimata erat kasd. Elitr sadipscing eos dolor tempor justo amet et dolor et, duo duo.

=para
Sit et ipsum sed kasd sed. Dolor sed dolor eos rebum stet invidunt amet, justo eirmod et clita sed no.

=begin para
Eos duo justo et dolores eos, stet sed amet stet tempor eirmod no. Kasd duo est ut tempor dolor et..

Sit sed et tempor rebum sanctus diam ipsum eos amet, sit rebum stet elitr ipsum voluptua. Sed et sit ipsum.
=end para
```

Burada begin ve end blokları şeklinde kullandığımızda boş satır kullanabildiğimize dikkat edelim.

==== Kod Blokları

Pod içerisinde kod yazabilmemize olanak verir. *=begin code* ve *=end code* bloklarının arasına kodumuzu yazabiliriz.

```perl6
=begin code
my $ad = 'Yalın';
say $ad;
=end code
```

==== Listeler

Listeler Pod içerisinde *=item* tanımlayıcısı ile tanımlanır. Yine seviyeli listelerde =headN kullanımına benzer şekilde *itemN* şeklinde kullanılabilir.

```perl6
=item Kanguru
=item Papağan
=item Kaplumbağa

=item1 Hayvanlar
=item2  Kanguru
=item2  Papağan
=item2  Kaplumbağa
```

Bunun yanında tanım listeleri de kullanabiliriz. Tanım listeleri için *=defn* kullanılır.

```perl6
=defn Gece Körlüğü
Beslenmede A vitamini yetersizliğinden ortaya çıkan bir hastalık belirtisi, tavukkarası.

=defn Renk Körlüğü
Bütün renkleri veya birkaç rengi, özellikle kırmızı ile yeşili birbirinden ayırt etmeye engel olan görme bozukluğu.
```

Paragraf listeleride kullanabiliriz.

```perl6
=begin item
I<Tavır:>
 
Özürlerden kaçın, seçeneksun, hata gerçekleşmeden yedek planlar yap.
=end item
 
=begin item
I<Bilgi:>
 
Bilgiye yatırım en yüksek faizi getirir.
=end item
```

==== Tablolar

Bir Pod dokümanında tabloları *=begin table* ve *=end table* blokları içerisinde tanımlarız. *=begin table :caption<Tablo Adı>* şeklinde tablomuza isim verebiliriz.

Basit bir tablo örneği şuna benzer.

```perl6
=begin table :caption<Bu benim ilk tablom>
Başlık, Sütun 0 | Başlık, Sütun 1
======================
Satır 0     | Satır 0
Sütun 0     | Süun 1
----------------------
Satır 1     | Satır 1
Sütun 0     | Sütun 1
----------------------
=end table
```


==== Pod Yorumları

Pod yorumları kodumuzda kullandığımız yorumlar gibi çalışır. Pod doküman oluşturucu tarafından yok sayılır.

```perl6
=comment Bu bir yorumdur.

=begin comment
Çok satırlı
bir
yorum.
=end comment
```

==== Format

Pod metin formatı kodları tanımlayıcı bir büyük harf ve sonrasında "*<>*" işaretleri ile kullanılır. Şöyle bir kullanıma sahiptir: BüyükHarf<>.

Kullanılabilecek harfler: B, C, E, I, K, L, N, P, R, T, U, V, X, ve Z'dir. Burada çok kullanılanlara değineceğiz.

Daha fazla bilgiye: https://docs.perl6.org/language/pod#Formatting_codes adresinden ulaşabilirsiniz.

*Bold:* B<>
*İtalik:* I<>
*Altıçizili:* U<>
*Kod:* C<>
*Bağlantılar:* L<>
*Yorumlar:* Z<>
*Alt Notlar:* N<>
*Unicode:* E<>

```perl6
=para
    Perl 6 B<harikadır.>
    Perl 6 I<harikadır.>
    Perl 6 U<harikadır.>
    C<my $a = 1; say $a;>
    Perl 6 anasayfası L<https://perl6.org>
    Perl 6 harikadır. Z<Bu bir yorum>
    Perl 6 bir çok paradigmayı destekler. N<Emirsel, Nesne Yönelimli ve Fonksiyonel>
```

=== Pod Doküman Yapısı

Sea aliquyam labore et sanctus nonumy sed ipsum amet invidunt dolore, elitr lorem aliquyam eos sed, sanctus erat justo clita.

=== Pod Dokümanını Dışarı Aktarma

Pod dokümanını birçok şekilde dışarıya aktarabiliriz. Şimdi bu yöntemleri inceleyelim.

Dışa aktarma işlemi için çeşitli modüller kullanırız. Bu modülleri _zef_ modül yöneticisi aracılığı ile kurabiliriz.

==== HTML

Bir Pod dokümanını HTML olarak dışarı aktarmak için *Pod::To::HTML* modülüne ihtiyaç duyarız. Eğer modül sisteminizde kurulu değilse *zef install Pod::To::HTML* komutu ile kurabilirsiniz.

Modül hakkında daha fazla bilgiye https://github.com/perl6/Pod-To-HTML adresinden ulaşabilirsiniz.

Kullanımına bakacak olursak:

```bash
$ perl6 --doc=HTML program.p6 > output.html
```

Şeklinde kullanabiliriz. Bu komut ile output.html isminde bulunduğunuz dizinde bir dosya oluşturulur.

==== Markdown

Bir Pod dokümanını Markdown olarak dışarı aktarmak için *Pod::To::Markdown* modülüne ihtiyaç duyarız. Eğer modül sisteminizde kurulu değilse *zef install Pod::To::Markdown* komutu ile kurabilirsiniz.

Modül hakkında daha fazla bilgiye https://github.com/softmoth/perl6-pod-to-markdown adresinden ulaşabilirsiniz.

Kullanımına bakacak olursak:

```bash
$ perl6 --doc=Markdown program.p6 > output.md
```

Şeklinde kullanabiliriz. Bu komut ile output.md isminde bulunduğunuz dizinde bir dosya oluşturulur.

==== Metin

Bir Pod dokümanını metin belgesi olarak dışarı aktarmak için:

```bash
perl6 --doc basic_pod.p6 > output.txt
```

Komutunu kullanırız. Bu komut ile output.txt isminde bulunduğunuz dizinde bir dosya oluşturulur.

<<<

= Temel Veri Tipleri ve Değişken Kullanımı

Bu bölümde, diğer dillerden aşina olduğumuz temel veri türlerini Perl 6 üzerinde ele alacağız.

Perl 6, statik tipli dillerde olduğu gibi değişkenin tipinin baştan belirlendiği ve program boyunca tipinin değişmediği bir dil değildir. Kademeli tip(_gradual type_) belirtme kullanan bir dildir, yani oluşturduğumuz değişkenlerin tiplerini belirtmeyebileceğimiz anlamına gelir. Farklı türdeki verileri tanımlamak için aynı değişkeni kullanabiliriz. Aynı zamanda oluşturulan değişken için tür de belirtmemize izin verir ve bu değişkenin farklı veri türleri için kısıtlayabilir.

<<<

== Değişken Tanımlamak ve Değer Atamak

Her değişken program içerisinde kullanılmadan önce oluşturulmalıdır. Bir değişken oluştururken *my* anahtar kelimesini kullanırız. *my* geçerli kapsam için değişken tanımlar. Kapsamlara ileride değineceğiz.

```perl6
my $degisken;
```

Şeklinde bir değişken oluştururuz. Kullanımda gördüğümüz gibi önce _my $degişken-adı_ şeklinde bir kullanımı vardır. Bu kullanım bize bir değişken oluşturur ve bu değişken için _(Any)_ tipinde bir dönüş yapar. Yani bu değişken herhangi bir şey olabilir.

```bash
> my $degisken;
(Any)
```

Bir kere tanımlanmış değişkene değer atamak için *=* işleci kullanılır.

```bash
> $degisken = 1;
1
> $degisken
1
```

Bu değişken sabit değişken(Sabit değişkenleri ileride göreceğiz.) olmadığı için değerini istediğimiz zaman değiştirebiliriz.

```bash
> $degisken = 5;
5
```

Bir diğer değişken oluşturma yöntemi ise değişkenin değerini değişkeni oluşturken belirtmektir.

```bash
> my $deg = 2;
2
> $deg;
2
```

Yeri gelmişken noktalı virgül işareti Perl 6'ya ifadenin bittiğini belirtir. 

*$* işareti değişkenin yapısal tipini belirtir ve her zaman değişken adının önünde bulunur. $ ile sembolize edilen veri tipleri skaler veriler olarak geçer. İleride değineceğimiz diziler *@* ile sembolize edilirken hash yapıları *%* ile sembolize edilir. Bu kodun okunaklığını arttırır ve kullanım kolaylığı sağlar.

Bu sembollerin kullanılmaması hataya sebep olur.

```bash
> my sayi = 2;
===SORRY!=== Error while compiling:
Malformed my (did you mean to declare a sigilless \sayi or $sayi?)
------> my sayi⏏ = 2;
```

Değişkenleri adlandırırken dikkat etmemiz gereken kurallar vardır. Bir değişken sayı veya harf ile başlamalı, alt çizgi, tire, veya kesme işareti içerebilir.

```perl6
> my $ad_soyad;
(Any)
> my $ad-soyad;
(Any)
> my $ad'soyad;
(Any)
```

Değişken adlarının hepsi doğru ve birbirinden farklıdır. Ancak -, ' gibi işaretlerden sonra mutlaka bir harf gelmeli ve tekrar etmemelidirler. Örneğin aşağıda geçersiz isimlendirmeleri görüyoruz.

```bash
> my $ad--soyad
> my $ad''soyad
> my $'adsoyad
> my $adsoyad-1
```

Bunların tümü hatalıdır.

Skaler veriler bir tam sayı, kayan noktalı sayı, karakter dizileri gibi tek bir değeri saklayabilen verilerdir.

Biraz daha kullanım örneği yapalım.

```bash
> my $a = 2;
2
> my $b = $a * 5;
10
> say "\$b değişkenin değeri: $b";
$b değişkenin değeri: 10
```

*\* işareti ile o değişkeni işleme sokmadan yazdıracağımızı belirttik.

```bash
> my $ad = 'Yalın';
Yalın
> my $soyad = 'Pala';
Pala
> say "Merhaba, $ad $soyad.";
Merhaba, Yalın Pala.
> say 'Merhaba, $ad $soyad';
Merhaba, $ad $soyad
```

Burada çift tırnak işareti ile tek tırnak işaretinin kullanım farklılığını görüyoruz. Çift tırnak işareti ekrana yazarken değişkenlerimizi işleme sokmuşken, tek tırnak işareti değişkenlerin varlığını umursamamış ve onlara karakter gibi davranmıştır.

<<<

== Sayılar

Bu bölümde tam sayıları(integer), rasyonel(rational) sayıları, kompleks(complex) sayıları göreceğiz. Kısaca aşinalık sağlamak için aşağıdaki gibi bir tablo yapabiliriz.

|=== 
| Değer | Sınıf(Class) | Açıklama  
| 12 | Int | Tam Sayı
| 3.1415926 | Rat | Rasyonel Sayı
| 6.026e34 | Num | Bilimsel Gösterim
| 1+0i| Complex | Kompleks, Karmaşık Sayılar
|=== 

```bash
> say 42;
42
> say 2123123123131231312312312312312123132123123123121231212311231231
2123123123131231312312312312312123132123123123121231212311231231
```

Burada ondalık(decimal) gösterim kullandık ancak Perl 6 bize çok daha fazlasını sunmakta onaltılık(Hexadecimal), sekizlik(octal), ikilik(binary) gösterimleride kullanabiliriz.

```bash
> say 13
13
> say :2<1101>
13
> say :8<15>
13
> say :16<D>
13
> say :16<d>
13
```

Şeklinde sayı sistemlerini kullanabiliriz. Alfabetik karakterler büyük-küçük harf duyarlılığına sahip değildir.

Büyük sayıların okunabilirkiğini arttırmak için *_* alt tire işareti kullanabiliriz.

```bash
> say 1_000_000_000
1000000000
> say 599_999_99_99
5999999999
```

Şimdi bazı tam sayı metotlarına bakalım:

*.chr:* Bir tam sayı değeri karaktere çevirir.

```bash
> say 65.chr
A
> say 66.chr
B
```

*.is-prime:* Bir tam sayının asal olup olmadığını kontrol eder.

```bash
> 3.is-prime
True
> 8.is-prime
False
```

*.rand:* Belirli aralıkta rastgele sayı üretir.

```bash
> 10.rand
7.951998306157705
> 100.rand
23.118963811372407
> 100.rand.truncate
74
> 10.rand.truncate
6
> 10.rand.truncate.WHAT
(Int)
> 10.rand.WHAT
(Num)
```

Burada _.rand_ metodunun sonucunu *.truncate* metodu ile yalnızca tam sayı kısmını almasını söyledik. tip dönüşüm işlemlerine ileride değineceğiz. _.WHAT_ metodu bize hangi sınıfa ait bir veri ile çalıştığımızı döndürdüğünü hatırlayalım.

```bash
> my $a = 1/4
0.25
> $a.WHAT
(Rat)
> $a.numerator
1
> $a.denominator
4
> (1/4 + 1/3).perl
<7/12>
```

Bir rasyonel sayının pay ve paydasını *.numerator* ve *.denominator* metotları ile bulabiliriz.

*.perl* metodu ise rasyonel işlemler yapmamızı sağlar. Pay ve paydayı korur. 

Bir rasyonel sayıyı yuvarlamak istiyorsak *.round* metodunu kullanabiliriz.

```bash
> 2.2.round
2
> 2.6.round
3
```

Bir sayının işaretini *.sign* metodu ile öğrenebiliriz. Bu metot sayı eksi ise *-1* artı ise *1* sonucunu döner.

```bash
> 3.sign
1
> -3.sign
-1
```

<<<

== Karakter Dizileri

Karakter dizileri(String) *Str* sınıfından türetilmiş nesnelerdir. Hemen bir örnek vermek gerekirse:

```bash
> my $karakter-dizisi = "Ben bir karakter dizisiyim!"
Ben bir karakter dizisiyim!
> $karakter-dizisi.WHAT
(Str)
```

Karakter dizilerini ekrana yazdırırken bize yardımcı olan kaçış karakterleri vardır. Örneğin:

```bash
> say "Ankara'da"
Ankara'da
> say 'Ankara'da'
[hata mesajı]
```

Tırnakların kullanımı karakter dizileri için önemlidir. Peki yukarıda hata mesajı aldığımız ifadeyi nasıl yazabilirdik. İşte bu noktada kaçış karakterleri dediğimiz karakterler işimize yarar.

```bash
> say 'Ankara\'da'
Ankara'da
> say 'Ankara \\ Yenimahalle'
Ankara \ Yenimahalle
```

Bu kullanımı önceki bölümlerde değişkenin işleme sokulmadan yazdırılması için de kullandığımızı hatırlayın. Burada ters eğik çizginin(*\*) kaçış karakteri olduğunugörüyoruz. Ekrana ters eğik çizgi yazdırmak için iki ters eğik çizgi kullanıldığına diikat edelim.

Bazı kaçış dizisi karakterlerine bakalım.

|=== 
| Karakter | Açıklama  
| \a | Ses karakteri
| \b | Geri alma tuşu
| \n | Yeni satır
| \t | Tab
| \f | Form
| \c[NAME] | Karakter adıyla
| \q[...] | Tek tırnaklı yazım
| \qq[...] | Çift tırnaklı yazım
| \x[ABCD] | Hex kodu ile karakter yazım
|===

Farklı bir kullanım tekniği ise daha özgür bir kullanım imkanı sunan *q<sınırlayıcı>* kullanımıdır. Bu kullanımda istediğimiz sırılayıcı karakterleri kullanabiliriz. 

```bash
> say q<<Ankara'da biri var>>
Ankara'da biri var
> say q{Ankara \ Yenimahalle}
Ankara \ Yenimahalle
```

İki karakter dizisini birleştirmek için *~* işlecini kullandığımızı görmüştük.

```bash
> my $ad = 'Yalın';
Yalın
> say "Merhaba " ~ $ad ~ "!";
Merhaba Yalın!
> say "Merhaba" ~ " " ~ "Dünya"
Merhaba Dünya
```

Farklı bir karakter dizisi birleştirme yöntemi ise *join* fonksiyonu kullanmaktır. *.chars* metodu ise bize karakter dizimizin boyutunu verir. *.uc*(_uppercase_) metodu ile karakter dizisi içerisindeki tüm karakterleri büyük, *.lc*(_lowercase_) metodu ile küçük harfe çevirdik. *.tc* metodu ile ilk karakteri büyük, *.tclc* metodu ile ilk karakteri büyük, kalan karakterleri küçük hale çevirdik.

```bash
> my $ad-soyad = join ' ', 'Yalın', 'Pala'
Yalın Pala
> 'Yalın'.chars
5
> 'yalın'.uc
YALIN
> 'YalıN'.lc
yalın
> 'Yalın PALA'. tclc
Yalın pala
```

Bir karakter dizisinin içine bakmak istersek *.contains()* metodunu kullanabiliriz. Metot karakter dizimizin içine bakarak belirttiğimiz karakterin veya karakterlerin, karakter dizisi içerisinde varsa _True_ yoksa _False_ sonucunu döner. Metodun büyük-küçük harf duyayarlılığı vardır.

*.start-with()* metodu ile metnin başlangıç karakterlerini, *.ends-with()* ile bitiş karakterlerinin belirttiğimiz karakterler olup olmadığını sorgulayabliriz.

```bash
> 'Örnek cümlemiz Perl 6 karakter dizileri'.contains('perl')
False
> 'Örnek cümlemiz Perl 6 karakter dizileri'.contains('Perl')
True
> 'Örnek cümlemiz Perl 6 karakter dizileri'.contains: 'Perl'
True
> 'Örnek cümlemiz Perl 6 karakter dizileri'.starts-with('Örne')
True
> 'Örnek cümlemiz Perl 6 karakter dizileri'.starts-with: 'leri'
False
> 'Örnek cümlemiz Perl 6 karakter dizileri'.ends-with: 'leri'
True
```

*.fc* metodu ile büyük-küçük harf duyarlılığını kapatabiliriz.

```bash
> 'Örnek cümlemiz Perl 6 karakter dizileri'.starts-with: 'örnek'
False
> 'Örnek cümlemiz Perl 6 karakter dizileri'.fc.starts-with: 'örnek'
True
```

*.index:* ile bir karakterin kaçıncı sırada olduğunu öğrenebiliriz. Burada dikkat etmemiz gereken nokta *.chars* metodundan farklı olarak *.index:* metodu saymaya sıfırdan başlar. Olmayan bir karakter girdiğimizde ise _Nil_ sonucunu döner.

```bash
> 'Yalın'.index: 'ı'
3
> 'Yalın'.index: 'm'
Nil
```

Bir karakter dizisi içerisinden bir aralığın içerisini görmek istersek *.substr:* metodunu kullanabiliriz.

```bash
> 'Yalın Perl 6 Kitabı yazıyor...'.substr: 6, 6
Perl 6
> 'Yalın Perl 6 Kitabı yazıyor...'.substr: 13
Kitabı yazıyor...
```

İlk kullanımda 6. karakterden başla ve 6 karakteri getir dedik. İkinci bir parametre kullanmazsak karakter dizisi bitene kadar anlamına gelir.

Farklı bir metin kullanım yöntemi ise *Q* kullanımıdır. Q daha genelleştirilmiş bir kullanım sunar. Q tek başına kullanıldığında q gibi davranır.

```bash
> say Q<<Ankara'da biri var>>
Ankara'da biri var
> say Q{Ankara \ Yenimahalle}
Ankara \ Yenimahalle
```

Q işleminin davranışını değiştirmek için parametreler kullanırız. Bu parametreler Q harfinden sonra gelir ve : ile başlarlar.

```bash
> Q :q 'Bu metin \' işaretleri ile sınırlıdır. \\'
Bu metin ' işaretleri ile sınırlıdır. \
> Q :q <Bu metin ' ile değil \< ile sınırlıdır.>
Bu metin ' ile değil < ile sınırlıdır.
> Q :single 'Bu metin \' işaretleri ile sınırlıdır. \\'
Bu metin ' işaretleri ile sınırlıdır. \
```

*:q* parametresinin uzun hali *:single* parametresidir, ikiside aynı işi yapar. Bunun gibi *:qq* parametresinin uzun hali *:double* parametresidir.

```bash
> my $ad = 'Yalın'
Yalın
> Q :q 'Merhaba $ad'
Merhaba $ad
> Q :qq 'Merhaba $ad'
Merhaba Yalın
> Q :double 'Merhaba $ad'
Merhaba Yalın
```

*:c* parametresi ise yalnızca süslü parantez içini işleme sokar. *:s* parametresi ise yalnızca değişkenleri işleme sokar. *:b* parametresi ise yalnızca kaçış karakterleri ile ilgilenir. Q parametreleri birlikte kullanılabilir.

```bash
> Q :c 'Merhaba $ad \n {2 ** 4}'
Merhaba $ad 16
> Q :c 'Merhaba \n {$ad}'
Merhaba Yalın
> Q :s 'Merhaba $ad \n {2 ** 4}'
Merhaba Yalın \n {2 ** 4}
> Q :b 'Merhaba $ad \n {2 ** 4}'
Merhaba $ad
 {2 ** 4}
> Q :c :s :b 'Merhaba $ad \n {2 ** 4}'
Merhaba Yalın
 16
```

Bazı Q parametrelerinin bir tablosu:

|=== 
| Kısa Ad | Uzun Ad | Açıklama  
| :x | :exec | Shell komutunu çalıştırır ve sonucu döner.
| :q | :single | Kaçış karakterleriyle işleme girer.
| :qq | :double | :s, :a, :h, :f, :c, :b ile işleme girer.
| :s | :scalar | $ değişkenleri ile işleme girer.
| :a | :array | @ değişkenleri ile işleme girer.
| :h | :hash | % değişkenleri ile işleme girer.
| :f | :function | & çağrıları ile işleme girer. 
| :c | :closure | {...} süslü parantez içi ile işleme girer.
| :b | :backslash | Kaçış karakterleri ile etkileşime girer.
| :to | :heredoc | Here doc ayrıştırma sonucu.
| :v | :val | Mümkünse allomorph a dönüştürür.
|===

Son olarak *Here Doc*'tan bahsedelim. Here doc çok satırlı bir metin yazmanın özel bir yoldur. *:heredoc* veya kısaca *:to* parametresi ile tanımlanır.

```perl6
my $cok-satirli = Q :to<END>;
    Tıkanma'dan bir alıntı:
        Sahip olacağım her şey bir gün kaybedeceğim şeylerden sadece biri.
    Tıkanma'nın yazarı: Chuck Palahniuk
    END

say $cok-satirli; 
```

Kodun çıktısı:

```bash
Tıkanma'dan bir alıntı:
    Sahip olacağım her şey bir gün kaybedeceğim şeylerden sadece biri.
Tıkanma'nın yazarı: Chuck Palahniuk
```

:to parametresinden sonra gelen kapsayıcılar değişebilir. Örneğin // kullanılabilir. Kapsayıcının içerisine yazılan ifade de değişebilir ancak mutlaka son ifade ile aynı olması gerekir.

Here doc değişken kullanımını desteklemez. Eğer değişken kullanmak istiyorsanız farklı parametreler ile birlikte kullanmalısınız.

```perl6
my $yazar = 'Chuck Palahniuk';

my $cok-satirli = Q :qq :to<ALINTI>;
    Tıkanma'dan bir alıntı:
        Sahip olacağım her şey bir gün kaybedeceğim şeylerden sadece biri.
    Tıkanma'nın yazarı: $yazar
    ALINTI

say $cok-satirli; 
```

Kodumuzun çıktısı:

```bash
Tıkanma'dan bir alıntı:
    Sahip olacağım her şey bir gün kaybedeceğim şeylerden sadece biri.
Tıkanma'nın yazarı: Chuck Palahniuk
```

<<<

== Sabitler

Perl 6'da diğer dillerden aşina olduğumuz sabitler, bir değişkenin değerinin bir kere belirlenebildiği değişkenler vardır.

Sabitler *constant* anahtar kelimesi ile oluşturulur.

```bash
> constant $A = 4
4
> $A
4
> $A = 2
Cannot assign to an immutable value
  in block <unit> at <unknown file> line 1
```

Yukarıdaki örnekte de gördüğümüz gibi bir sabitin değerini değiştirmeye çalıştığımız da hata ile karşılaşırız. Yine değişkenlerden farklı olarak sabitlere ilk değer ataması yapılmak zorundadır aksi durumda hata ile karşılaşılır.

Sabitler varsayılan olarak *our* kapsayıcısını alır. Ancak *my* kapsayıcısını da alabilirler. Kapsayıcılara ilerideki bölümlerde değineceğiz.

```bash
> my constant $B = 4
4
> $B
4
> $B = 2
Cannot assign to an immutable value
  in block <unit> at <unknown file> line 1
```

Sabit adlandırırken büyük harfler kullanılması güzel bir alışkanlıktır.

Sabitleri tanımlarken değişken adını işaretsiz($, @, % olmaksızın) belirtebiliriz.

```bash
>constant DENEME = "Deneme"
Deneme
> DENEME
Deneme
> DENEME = "Fark!"
Cannot modify an immutable Str (Deneme)
  in block <unit> at <unknown file> line 1
```

Sabitleri oluşturmanın farklı bir yoluda işaretsiz değişken kullanımı gibi olan *\degisken* şeklinde kullanımdır.

```bash
> my \sabit = 4
4
> sabit
4
> \sabit
\(4)
> sabit = 3
Cannot modify an immutable Int (4)
  in block <unit> at <unknown file> line 1

> \sabit = 3
Cannot modify an immutable Capture (\(4))
  in block <unit> at <unknown file> line 1
```

<<<

== Değişken Tanımlama Yöntemleri

Perl 6 da değişkenlerin tiplerinin belirtilebileceğini söylemiştik. Bu bölümde değişken tanımlamanın farklı yöntemlerini göreceğiz.


=== Değişken Tipi Belirtme

Bir değişkenin tipini *my tip değişkenadı* şablonuna göre belirtiriz.

```bash
> my Int $a
(Int)
> $a = 4
4
> $a = "12"
Type check failed in assignment to $a; expected Int but got Str ("12")
  in block <unit> at <unknown file> line 1
> $a = 4.5
Type check failed in assignment to $a; expected Int but got Rat (4.5)
  in block <unit> at <unknown file> line 1
```

Örneğimizde görüldüğü gibi değişken tipi belirtildikten sonra o değişkenin tipinin dışında bir tipte değer alması hataya sebep olur.

```bash
> my Str $b = "Bir karakter dizisi"
Bir karakter dizisi
> $b = "farklı bir  karakter dizisi"
farklı bir karakter dizisi
> my Bool $c = True
True
```

Ancak aynı tipte olmak üzere değeri değiştirilebilir.

Şuana kadar gördüğümüz ve göreceğimiz, oluşturabileceğimiz bütün tipleri değişken oluştururken kullanabiliriz.

Farklı olarak sabitlerin tiplerini belirtemeyiz.

```bash
> constant Int $a = 4
===SORRY!=== Error while compiling:
Missing initializer on constant declaration
------> constant Int⏏ $a = 4
```


=== Çoklu Değişken Tanımlama

Elbette her satırda bir değişken tanımlamak zorunda değiliz. Bir satırda birden fazla değişken tanımlayabiliriz.

```bash
> my ($e, $f, $g)
((Any) (Any) (Any))
> $e = "e"
e
> $f = "f"
f
> $g = "g"
g
```

Tanımlama esnasında değer belirtebiliriz ve yine tek satırda bu değerleri değiştirebiliriz.

```bash
> my ($a, $b) = 1, 2
(1 2)
> $a
1
> $b
2
> ($e, $f, $g) = 1, 2, 3
(1 2 3)
> $g
3
> $f
2
> $e
1
```

Ayrıca bir önceki bölümde gördüğümüz gibi çoklu tanımlama yaparken de tip belirtebiliriz.

```bash
> my Str ($c, $d) = "Farklı", "kullanım"
(Farklı kullanım)
> $c
Farklı
> $d
kullanım
```

<<<

== Değişkenlerin Kapsamı ve Bloklar

Bloklar bir veya daha fazla ifadeyi süslü parantezler *{ ... }* ile çevirerek tek bir birim altında toplar. 

Bloklar döngüler, koşullar gibi ifadeler de görülebileceği gibi ifadesizde görülebilir. 

Bir blok kendi kapsamını yaratır.

```perl6
my $ad = "Yalın";
say $ad;

{
    # Burası bir blok
    my $ad = "Asu";
    say $ad;
}

say $ad;
```

Bu kodun çıktısı aşağıdaki gibi olur.

```bash
Yalın
Asu
Yalın
```

Bir blok icerisinde tanimlanan ifadeler yalniz o blok icerisinde kalan alanda gecerliligini korur.

<<<

== Tip Dönüşümleri

Genellikle bir değişkenin tipini değiştirmek için *$degisken.Tipadı* gibi bir kullanım vardır.

Bir kullanım çeşidi ise bir string ifadenin başına *+* işleci koymaktır. Bu değişkeni en olası numerik tipe çevirmeye çalışır. Tam tersi numerik bir tipi string'e çevirmek için *~* işleci numerik ifadenin başına konur.

```bash
> my $a = 3
3
> $a.WHAT
(Int)
> $a.Str.WHAT
(Str)
 my $b = 4.5
4.5
> $b.Int
4
> my Str $c = $b.Str
4.5
my Rat $d = +$c
4.5
> $d.WHAT
(Rat)
my Str $e = ~$b
4.5
> $e.WHAT
(Str)
```


<<<

= Listeler

